



在https://leetcode.cn/problemset/里搜题号，去文档里找答案。

acm模式可以直接ai

# 	根据输入参数分类

根据输入参数

【题号】，这样是全则匹配

**除了树、链表...**

1. 一维数组
2. 二维数组
3. 单变量
4. 多变量
5. 设计
6. 链表
7. 二叉树
8. 多线程

```java
// 创建栈
Stack<类型> stack = new Stack();
stack.push(...);
stack.pop();
stack.peek();

// 优先队列，默认小顶堆
A = new PriorityQueue();
// 大顶堆
B = new PriorityQueue((x, y) -> (y - x));

在 Java 中，Comparator 接口中的 compare 方法用于比较两个对象的顺序。这个方法的返回值决定了排序的顺序：
返回负数：如果第一个参数应该排在第二个参数之前，则返回一个负数。在升序排序中，这表示第一个参数小于第二个参数。
返回零：如果两个参数相等，则返回零。在排序时，这意味着这两个对象的顺序没有变化。
返回正数：如果第一个参数应该排在第二个参数之后，则返回一个正数。在升序排序中，这表示第一个参数大于第二个参数。
```





# 一维数组&列表

## 【1】、两数之和

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

Tag:哈希

```java
/*
    o(n)    n是数组的元素，每个元素都可以o(1)寻找到target-x
    o(n)    n是数组元素数量，主要是哈希表的开销
*/
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; ++i) {
        if (map.containsKey(target - nums[i])) {
            return new int[]{map.get(target - nums[i]), i};
        }
        map.put(nums[i], i);
    }
    return new int[0];
}
```

## 【4】、寻找两个正序数组的中位数

```java
/*
    求第k小数，每次循环排除k/2个数
    比较两个数组的第k/2个数字，哪个小表示该数组的前k/2个数字都不是第k小数字
    比如k=7，就比较A和B数组第7/2=3，A[2]和B[2]的大小，假如A[2]>B[2]，此时可以排除B[0/1/2]，因为此时比A[2]小的有2+3=5个，所以A[2]此时是第6小，可以确定B[2/0/1]一定不是第k小
    o(log(m+n))     每循环一次就少k/2个数，o(log(k))，k=(m+n)/2
    o(1)
 */
public double findMedianSortedArrays(int[] nums1, int[] nums2) {
    int n = nums1.length;
    int m = nums2.length;
    // 索引k + 1个数，才是第k个数
    int left = (n + m + 1) / 2;
    int right = (n + m + 2) / 2;
    // 将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k
    // 中位数！
    // 比如n=3，m=4，left=4，right=4，一共7个数刚好返回第4个数
    // 比如n=4，m=6，left=5，right=6，一共10个数返回第5和第6的均值
    return (getKth(nums1, 0, n - 1, nums2, 0, m - 1, left) +
            getKth(nums1, 0, n - 1, nums2, 0, m - 1, right)) * 0.5;
}

private int getKth(int[] nums1, int start1, int end1, int[] nums2, int start2, int end2, int k) {
    int len1 = end1 - start1 + 1;
    int len2 = end2 - start2 + 1;
    // 让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1
    if (len1 > len2) return getKth(nums2, start2, end2, nums1, start1, end1, k);
    // nums1没元素了，直接在nums2再找k个数，k代表个数不是索引，对应索引要-1
    if (len1 == 0) return nums2[start2 + k - 1];

    // 如果k是1，再找一个数，对应到索引-1，所以是nums1和nums2最小的那个就是答案
    if (k == 1) return Math.min(nums1[start1], nums2[start2]);
    // 为了防止数组长度小于k/2，每次都会和k/2比较，取最小的
    // 如果len小于k/2，说明数组经过下一次遍历就会到末尾，然后就会在剩余数组选中位数
    int i = start1 + Math.min(len1, k / 2) - 1;
    int j = start2 + Math.min(len2, k / 2) - 1;

    // 表示nums2包含j和之前的元素都淘汰，k减去淘汰个数，+1是因为索引相减会少一个，比如start2和j一样，排除j后k要减1
    if (nums1[i] > nums2[j]) {
        return getKth(nums1, start1, end1, nums2, j + 1, end2, k - (j - start2 + 1));
    } else {
        // 排除nums1之前的
        return getKth(nums1, i + 1, end1, nums2, start2, end2, k - (i - start1 + 1));
    }
}
```



## 【11】、盛最多水的容器

```java
/*
    两边指针每次向中间缩，每次让低的一边缩（这样可能低的会变高，面积增加），每次计算面积
    o(n)：双指针遍历一边底边宽度
    o(1)：常数变量
 */
public int maxArea(int[] height) {

    int i = 0;
    int j = height.length - 1;
    int ans = 0;
    while (i < j) {
        int area = (j - i) * Math.min(height[i], height[j]);
        ans = Math.max(ans, area);
        // 指针往中间缩，每次缩低的一边（这样可能后面的面积会大，让留下的边界可能更高）
        if (height[i] < height[j]) {
            i++;
        } else {
            j--;
        }
    }
    return ans;
}
```

## 【14】、最长公共前缀

```java
/*
	
*/
public String longestCommonPrefix(String[] strs) {
    if(strs.length == 0) 
        return "";
    // 令最长公共前缀为第一个字符串
    String ans = strs[0];
    for(int i = 1; i < strs.length; i++) {
        // 遍历后面字符串，依次和ans比较，最终结果就是最长公共前缀
        int j=0;
        for(; j < ans.length() && j < strs[i].length(); j++) {
            if(ans.charAt(j) != strs[i].charAt(j))
                break;
        }
        ans = ans.substring(0, j);
        if(ans.equals(""))
            return ans;
    }
    return ans;
}
```

## 【15】、三数之和

```java
/*
    o(n^2)    排序o(nlogn)，外循环o(n)，内循环最多n次，o(n)，内循环的总迭代次数由外层控制，最多n次
    o(1)      常数大小
 */
public List<List<Integer>> threeSum(int[] nums) {

    Arrays.sort(nums);
    List<List<Integer>> res = new ArrayList<>();
    // 循环初始位置，最大也要保证有三个
    for (int i = 0; i < nums.length - 2; i++) {
        // 一定不满足和为0，因为已经升序，不能以k开头
        if (nums[i] > 0) {
            break;
        }
        // 去重，不包含重复三元组
        if (i > 0 && nums[i] == nums[i - 1]) {
            continue;
        }
        int j = i + 1;
        int k = nums.length - 1;
        // j = k 就退出了
        while (j < k) {
            int sum = nums[i] + nums[j] + nums[k];
            if (sum < 0) {  // 变大
                j++;
            } else if (sum > 0) { // 变小
                k--;
            } else {
                // 添加结果
                //List.of快速船舰一个List
                res.add(List.of(nums[i], nums[j], nums[k]));
                // 左右指针都变化，继续找这个k对应的其他结果，跳过重复数字
				for (++j; j < k && nums[j] == nums[j - 1]; ++j); // 跳过重复数字
                for (--k; k > j && nums[k] == nums[k + 1]; --k); // 跳过重复数字
            }
        }
    }
    return res;
}
```

## 【16】、无重复字符的最长子串

```

// 时间复杂度：O(2n) = O(n)，最坏的情况是 left 和 right 都遍历了一遍字符串
// 空间复杂度：O(n)

public int lengthOfLongestSubstring(String s) {
    int n = s.length();
    if (n <= 1) return n;
    int maxLen = 1;

    int left = 0, right = 0;
    Set<Character> window = new HashSet<>();
    while (right < n) {
        char rightChar = s.charAt(right);
        while (window.contains(rightChar)) {
            window.remove(s.charAt(left));
            left++;
        }
        maxLen = Math.max(maxLen, right - left + 1);
        window.add(rightChar);
        right++;
    }

    return maxLen;
}




```









## 【27】、移除元素

```java
/*
        快慢指针
        快指针：找新数组元素，即不含有目标元素的数组
        慢指针：指向更新新数组下标的元素
        o(n)
        o(1)
     */
public int removeElement(int[] nums, int val) {

    int slow = 0;
    for (int fast = 0; fast < nums.length; fast++) {
        // 如果fast指向元素不是val，则一定是输出数组的一个元素，就把fast的元素移到slow的位置，然后fast和slow同时右移
        // 如果fast指向元素等于val，则对应不能在输出数组内，则slow不动，fast右移1
        if (nums[fast] != val) {
            nums[slow++] = nums[fast];
        }
    }
    return slow;
}
```

## 【31】、下一个排列

```java
/*
    将左边的较小数和右边的较大数交换，较小数尽量靠右，较大数尽量小，交换后，较大数右边的数要升序排列
    先从后往前查找第一个升序即左边的较小数(i, i+1),a[i] < a[i+1],此时[i+1, n]必然是下降序列，较小数是a[i]
    再从[i+1, n]中从后向前找第一个j满足a[i]<a[j]，a[j]就是右边的较大数
    交换a[i]和a[j]，此时[i+1, n]是降序，最后用双指针变为升序
    o(n)    最多扫描两次序列，进行一次翻转
    o(1)
 */
public void nextPermutation(int[] nums) {
    int i = nums.length - 2;
    // 因为找较小数要尽量靠右，所以从右往左遍历，找小
    //1.找到递减序列的起点
    while (i >= 0 && nums[i] >= nums[i + 1]) {
        i--;
    }
    // i<0说明整个是降序
    if (i >= 0) {
        int j = nums.length - 1;
        // 找右边的较大数
        //找出右边比 nums[i] 大的最小元素
        while (j >= 0 && nums[i] >= nums[j]) {
            j--;
        }
        // 交换
        swap(nums, i, j);
    }
    // 翻转
    reverse(nums, i + 1);
}

public void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}

public void reverse(int[] nums, int start) {
    int left = start;
    int right = nums.length - 1;
    while (left < right) {
        swap(nums, left, right);
        left++;
        right--;
    }
}
```

## 【33】、搜索旋转排序数组

```java
/*
    如果前半段有序就在前半段找，否则在后半段找
    一定是要么左边有序，要么右边有序
    o(logn)
    o(1)
 */
public int search(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    // left等于right的时候还要再判断找到没
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[left] <= nums[mid]) {
            // 左半部分有序
            // target在左半部分，就收缩右边
            if (target >= nums[left] && target < nums[mid]) {
                right = mid - 1;
            } else {
                // 在右半部分，收缩左边
                left = mid + 1;
            }
        } else {
            // 右半部分有序
            if (target <= nums[right] && target > nums[mid]) {
                // target在右半部分，收缩左边
                left = mid + 1;
            } else {
                // 在左半部分，收缩右边
                right = mid - 1;
            }
        }
    }
    return -1;
}
```



## 【34】、在排序数组种查找元素的第一个和最后一个位置

```java
/*
    先找第一个大于等于的位置，再找最后一个小于等于的位置
    1. 找第一个该元素
    大于等于target，收缩右边，mid
    小于target，收缩左边，mid + 1
    2. 找最后一个该元素
    小于等于target，收缩左边，mid
    大于target，收缩右边，mid - 1
    o(logn)     二分，一共执行2次
    o(1)
 */
public int[] searchRange(int[] nums, int target) {
    if (nums == null || nums.length == 0) return new int[] {-1, -1};
    int left = 0;
    int right = nums.length -1;
    // 找第一个大于等于的位置
    while (left < right) {
        int mid = left + (right - left) / 2;
        // 大于等于目标值，说明第一个在左边，可能是当前，收缩右边
        if (nums[mid] >= target) {
            right = mid;
        } else {
            // 比目标值小，收缩左边
            left = mid + 1;
        }
    }
    if (nums[right] != target) return new int[] {-1, -1};
    int L = right;
    left = 0;
    right = nums.length - 1;
    // 找最后一个等于的位置
    while (left < right) {
        // 不加1的话，如果[8,9]，left0，right1，会死循环，因为mid是中间靠左边，要找最右边的就要+1
        int mid = left + (right - left) / 2 + 1;
        // 比目标值小或相等，就可能在右边，收缩左边
        if (nums[mid] <= target) {
            left = mid;
        } else {
            // 比目标值大，收缩右边
            right = mid - 1;
        }
    }
    return new int[] {L, right};
}
```



## 【35】、搜索插入位置

```java
/*
    在一个有序数组找第一个大于等于target的下标
    大于等于target，记录答案，收缩右边，m - 1
    小于target，收缩左边，m + 1
    o(n)    二分查找
    o(1)
*/
public int searchInsert(int[] nums, int target) {
    int l = 0;
    int r = nums.length - 1;
    // 默认插入最后一个
    int ans = nums.length;
    while (l <= r) {
        int m = l + (r - l) / 2;
        // 大于等于target就记录下标
        if (nums[m] >= target) {
            ans = m;
            r = m - 1;
        } else {
            l = m + 1;
        }
    }
    return ans;
}
```



## 【39】、组合总和

```java
/*
    元素无限选
    不区分顺序，4,5和5,4一样，需要剪枝，如第一轮4，5，第二轮先5的时候就要跳过4，所以每次从index开始遍历
    o(n*2^n)    远小于这个，n个位置每次考虑选不选，还有剪枝，加入结果o(n)
    o(target)   最差情况递归target层
 */
List<List<Integer>> res = new ArrayList<>();
List<Integer> path = new ArrayList<>();
public List<List<Integer>> combinationSum(int[] candidates, int target) {
    Arrays.sort(candidates);
    dfs(candidates, 0, target);
    return res;
}

private void dfs(int[] candidates, int index, int t) {
    // 子集和等于target，记录
    if (t == 0){
        res.add(new ArrayList<>(path));
        return;
    }
    // 从index开始遍历，避免生成重复子集
    for (int i = index; i < candidates.length; i++){
        // 剪枝，如果子集和超过target<就直接结束
        if (t - candidates[i] < 0) break;
        // 回溯
        path.add(candidates[i]);
        dfs(candidates, i, t - candidates[i]);
        path.remove(path.size() - 1);
    }
}
```



## 【41】、缺失的第一个正数

```java
/*
    原地置换，先将数字放到正确位置，最后从第一个位置向后遍历，哪个位置没有就返回
    o(n)
    o(1)
 */
public int firstMissingPositive(int[] nums) {
    int n = nums.length;
    // 比如nums[i] = 3    3如果不在nums[i]的位置，就交换，再判断下一个是否在指定位置
    for (int i = 0; i < n; i++) {
        while (nums[i] > 0 && nums[i] < n && nums[nums[i] - 1] != nums[i]) {
            int t = nums[nums[i] - 1];
            nums[nums[i] - 1] = nums[i];
            nums[i] = t;
        }
    }
    // 此时，合适的数字会回到对应位置，遍历每一个位置，判断那个位置的值是否合适
    for (int i = 0; i < n; i++) {
        if (nums[i] != i + 1) {
            return i + 1;
        }
    }
    return n + 1;
}
```

## 【42】、接雨水

```java
/*
	双指针，看图，每次向中间收缩，利用左右的最大值获得对应格子能接雨水的个数
	维护 left 和 right 两个指针，和两个变量 leftMax和rightMax，left只向右，right只向左，移动中维护两个变量
	o(n)
	o(1)
*/
public int trap(int[] height) {

    int n = height.length;
    int left = 0;
    int right = n - 1;
    int leftMax = 0;
    int rightMax = 0;
    int ans = 0;
    while (left < right) {
        // 更新最大值
        leftMax = Math.max(leftMax, height[left]);
        rightMax = Math.max(rightMax, height[right]);
        // 选择计算的格子，哪边低就是哪边可能有积水
        if (leftMax < rightMax) {
            ans += leftMax - height[left];
            ++left;
        } else {
            // 否则后缀向前，后缀最大值小于前缀最大值，肯定选右边
            ans += rightMax - height[right];
            --right;
        }
    }
    return ans;
}
```

## 【45】、跳跃游戏II

```java
/*
    贪心，每次找可到达的最远位置
    o(n)
    o(1)
 */
public int jump(int[] nums) {
    int n = nums.length;
    // 本回合可以走的最远距离
    int end = 0;
    int max = 0;
    int step = 0;
    // 不访问最后一个元素，是因为如果end是终点的话，就没必要step++（访问最后一个的话，如果到i==end，就再++）
    for (int i = 0; i < n - 1; i++) {
        // 先更新max
        max = Math.max(max, i + nums[i]);
        // 如果到了一个end，就更新能到的最远，相当于每次都是选跳的最远的路
        if (i == end) {
            end = max;
            step++;
        }
    }
    return step;
}
```

## 【46】、全排列

```java
/*
    先固定第1位元素（n种情况），再固定第2位元素（n - 1种情况）
         
      	2——3
      /
    1
      \
      	3——2
    	1——3
      /
    2
      \
      	3——1
    o(n!n)  每次固定时交换n个元素，总共o(n!)，同时每次加入排列方案的操作也是o(n)
    o(n)    全排列的递归深度是 n
 */
List<Integer> nums;
List<List<Integer>> res;
public List<List<Integer>> permute(int[] nums) {

    this.res = new ArrayList<>();
    this.nums = new ArrayList<>();
    for (int num : nums) {
        this.nums.add(num);
    }
    dfs(0);
    return res;
}
public void dfs(int x) {
    if (x == nums.size() - 1) {
        res.add(new ArrayList<>(nums));
        return;
    }
    for (int i = x; i < nums.size(); i++) {
        // 交换，即把nums[i]固定在第x位
        swap(i, x);
        // 开始固定下一位
        dfs(x + 1);
        // 恢复交换
        swap(i, x);
    }
}
void swap(int a, int b) {
    int tmp = nums.get(a);
    nums.set(a, nums.get(b));
    nums.set(b, tmp);
}
```



## 【49】、字母异位词分组

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

【把字母数量相同的字符串分到一组】示例：["nat","tan"]都是一个a，一个n，一个t，所以分到一组。["ate","eat","tea"]都是一个a，一个e，一个t，所以分到一组。

```java
/*
    o(nklogk)   n是strs的字符串数量，k是strs中字符串的最大长度，需要遍历n个字符串，对于每个字符串，需要o(klogk)的时间进行排序和
                o(1)的时间更新哈希表，总时间复杂度是 o(nklogk)
    o(nk)       n是字符串数量，k是字符串最大长度，需要用哈希表存储全部字符串
*/
public List<List<String>> groupAnagrams(String[] strs) {

    List<List<String>> res = new ArrayList<>();
    // key为共同拥有字符的标识，值是对应字符组合的多种结果
    Map<String, List<String>> map = new HashMap<>();
    for (String str : strs) {
         char[] chars = str.toCharArray();
        Arrays.sort(chars);
        String key = new String(chars);
        //方法获取当前键 key 对应的字符串列表，如果键不存在则初始化一个新的列表
        List<String> list = map.getOrDefault(key, new ArrayList<String>());
        list.add(str);
        map.put(key, list);
    }
    return new ArrayList<>(map.values());
}
```

## 【53】、最大子数组和

```java
/*
    优化的动态规划，nums[i]代表以原nums[i]结尾的连续子数组最大和
    o(n)    遍历数组
    o(1)    常数空间    直接在nums上进行修改
 */
public int maxSubArray(int[] nums) {
    int ans = nums[0];
    for (int i = 1; i < nums.length; i++) {
        // 上一个大于0，就可以更新当前以i结尾的连续最大和，正收益
        if (nums[i - 1] > 0) {
            nums[i] += nums[i - 1];
        }
        ans = Math.max(ans, nums[i]);
    }
    return ans;
} 

//解法2
  public int maxSubArray(int[] nums) {
        int sum=0;
        int ans=nums[0];
        for(int num: nums){
            if(sum>0){
                sum+=num;
            }else{
                sum=num;
            }

            ans=Math.max(sum,ans);
        }
        return ans;
    }
}

```

## 【55】、跳跃游戏

```java
/*
    贪心
    更新最远到达的边界，看能不能到最后一个
    o(n)
    o(1)
 */
public boolean canJump(int[] nums) {
    if (nums == null || nums.length == 0) return true;
    int n = nums.length;
    // 最远到达下标
    int remote = 0;
    for (int i = 0; i < n; i++) {
        // 如果能到当前下标，才尝试更新最远
        if (remote >= i) {
            remote = Math.max(remote, i + nums[i]);
        }
    }
    // 能到最后一个
    if (remote >= n - 1) {
        return true;
    }
    return false;
}
```



## 【75】、颜色分类

```java
/*
    把两边排好，中间自然就排好了
    o(n)
    o(1)
 */
public void sortColors(int[] nums) {
    int n = nums.length;
    int p0 = 0;
    int p2 = n - 1;
    for (int i = 0; i <= p2; i++) {
        // 如果是第三部分的，就交换，交换后如果当前还是2，就继续交换
        while (i <= p2 && nums[i] == 2) {
            int t = nums[i];
            nums[i] = nums[p2];
            nums[p2] = t;
            p2--;
        }
        // 如果是第一部分的，就向第一部分加
        if (nums[i] == 0) {
            int t = nums[i];
            nums[i] = nums[p0];
            nums[p0] = t;
            p0++;
        }
    }
}
```



## 【78】、子集

```java
/*
    o(n*2^n)    每次都是选或不选，递归次数是满二叉树节点数，一共递归2^n次，加入答案需要o(n)
    o(n)
 */
List<List<Integer>> res;
List<Integer> path = new ArrayList<>();
public List<List<Integer>> subsets(int[] nums) {
    res = new ArrayList<>();
    process(nums,0);
    return res;
}

private void process(int[] nums, int index) {
    //到头了
    if(index == nums.length){
        res.add(new ArrayList<>(path));
        return;
    }
    //不加该index
    process(nums, index + 1);
    //加该index
    path.add(nums[index]);
    process(nums, index + 1);
    path.remove(path.size() - 1);
}
```



## 【80】、删除排序数组中的重复项II

```java
/*
	双指针
	因为数组有序，所以相同的元素肯定是连续的，遍历数组检查每一个元素是否应该被保留，如果应该被保留，就将其移动到指定位置
	因为本题要求相同元素最多出现两次而非一次，所以我们需要检查上上个应该被保留的元素 nums[slow−2]是否和当前待检查元素 nums[fast]相同。当且仅当 nums[slow−2]=nums[fast]时，当前待检查元素 nums[fast]不应该被保留
*/
public int removeDuplicates(int[] nums) {
    int n = nums.length;
    if (n <= 2) {
        return n;
    }
    // slow：处理出的数组的长度
    // fast：已经检查过的数组的长度
    // nums[fast] 表示待检查的第一个元素，nums[slow−1]\textit{nums}[\textit{slow} - 1]nums[slow−1] 为上一个应该被保留的元素所移动到的指定位置。
    int slow = 2, fast = 2;
    while (fast < n) {
        if (nums[slow - 2] != nums[fast]) {
            nums[slow] = nums[fast];
            ++slow;
        }
        ++fast;
    }
    return slow;
}
```

## 【84】、柱状图中最大的矩形

```java
/*
	普通做法：对于每个柱子，都找左右可以扩张的最大边界（第一个小于该柱子高度的位置），然后更新最大面积
	单调栈：一次遍历确定左右边界，比如第一个柱子是2，第二个是1，遍历到第2个时，因为1<2，所以此时可以确定第一个柱子2的矩形面积，则出栈计算
	​一个单调递增的栈​（栈内元素对应柱子高度递增）。当遇到比栈顶小的柱子时，说明栈顶柱子的右边界确定，计算其最大矩形面积。栈内剩余元素，即栈顶的下一个元素，确定左边界。
	o(n)
	o(n)
*/
public int largestRectangleArea(int[] heights) {
    int res = 0;
    Stack<Integer> stack = new Stack();
    for (int i = 0; i <= heights.length; i++) {
        // 1.遍历到最后，需要出栈
        // 2.之前栈的高度大于当前柱子高度，就可以确定之前栈元素的面积
        while ((!stack.isEmpty() && i == heights.length) ||
               (!stack.isEmpty() && heights[stack.peek()] > heights[i])) {
			
            int k = stack.pop();
            int right = (i - k) * heights[k];
            int left = (stack.isEmpty() ? k : k - stack.peek() - 1) * heights[k];
            res = Math.max(res, left + right);
        }
        stack.push(i);
    }
    return res;
}
```



## 【88】、合并两个有序数组

```java
/*
	o(m+n)
	o(m+n)
*/
public void merge(int[] nums1, int m, int[] nums2, int n) {
    int p1 = 0, p2 = 0;
    int[] sorted = new int[m + n];
    int cur;
    while (p1 < m || p2 < n) {
        if (p1 == m) {
            cur = nums2[p2++];
        } else if (p2 == n) {
            cur = nums1[p1++];
        } else if (nums1[p1] < nums2[p2]) {
            cur = nums1[p1++];
        } else {
            cur = nums2[p2++];
        }
        sorted[p1 + p2 - 1] = cur;
    }
    for (int i = 0; i != m + n; ++i) {
        nums1[i] = sorted[i];
    }
}
```

## 【121】、买卖股票的最佳时机；o63、股票的最大利润

```java
/*
	只能1天买1天卖，1次
    为了达到最高利润，就一定选择价格最低的时候买入，贪心
    更新前i天的最低买入成本
    更新前i天的最高利润
    o(n)
    o(1)
 */
public int maxProfit(int[] prices) {
    // 前i天最低成本
    int cost = Integer.MAX_VALUE;
    // 前i天最高利润
    int profit = 0;
    for (int price : prices) {
        // 更新最高利润，如果是今天卖出
        profit = Math.max(price - cost, profit);
        // 更新最低成本，如果今天可以买入
        cost = Math.min(price, cost);
    }
    return profit;
}
```

## 【122】、买卖股票的最佳时机II

```java
/*
        贪心，所有上涨都买卖，所有下降都不买卖
        可以多次买卖，求最大利润
        o(n)
        o(1)
     */
public int maxProfit(int[] prices) {
    int profit = 0;
    for (int i = 1; i < prices.length; i++) {
        int tmp = prices[i] - prices[i - 1];
        // 所有上涨都买卖
        if (tmp > 0) profit += tmp;
    }
    return profit;
}
```



## 【128】、最长连续序列

```java
/*
    o(n)    n是数组长度  时间复杂度要看具体执行次数，每个元素最多遍历两次（最坏情况是全部有序，外层循环n次，内层只有最小的会进入内循环（循环n次），所以一共循环2n次，最好情况没有连续的，全部都只有外循环，有连续的内部加起来就是总连续次数）
    o(n)    set保存数组中所有数

 */
public int longestConsecutive(int[] nums) {

    Set<Integer> set = new HashSet();
    for (int num : nums) {
        set.add(num);
    }
    int res = 0;
    // 每次从num出发
    for (int num : set) {//遍历set直接就去重了
        int cur = num;
        // 包含之前的，就用最之前的算
        if (set.contains(cur - 1)) {
            continue;
        }
        // 每次向后试探
        while (set.contains(cur + 1)) {
            cur++;
        }
        res = Math.max(res, cur - num + 1);
    }
    return res;
}
```

## 【136】、只出现一次的数字

```java
/*
    不同为1
    a ^ 0 = a
    a ^ a = 0
    a ^ b ^ a = b
    o(n)
    o(1)
 */
public int singleNumber(int[] nums) {
    int ans = 0;
    for (int i = 0; i < nums.length; i++) {
        ans ^= nums[i];
    }
    return ans;
}
```

## 【139】、单词拆分

```java
/*
	动态规划
	o(n^2)
	o(n)
*/
public boolean wordBreak(String s, List<String> wordDict) {
    Set<String> set = new HashSet(wordDict);
    // dp[i]表示字符串s前i个字符组成的字符串s[0...i-1]能否被空格拆分为若干个字典中出现的单词
    // dp[i] = dp[j] && check(s[j..i-1])，check表示子串s[j..i-1]是否出现在字典里
    boolean[] dp = new boolean[s.length() + 1];
    dp[0] = true;
    for (int i = 1; i <= s.length(); i++) {
        // 枚举切开的位置
        for (int j = 0; j < i; j++) {
            if (dp[j] && set.contains(s.substring(j, i))) {
                // 如果前j个组成的字符串可以拆，同时后面的字符串出现在字典里，则说明前i个都可以出现在字典里
                dp[i] = true;
                break;
            }
        }
    }
    return dp[s.length()];
}
```

## 【140】、单词拆分II

```java
/*
	dfs回溯
	最多
*/
List<String> res = new ArrayList();
List<String> path = new ArrayList();
Set<String> set;
public List<String> wordBreak(String s, List<String> wordDict) {
    set = new HashSet(wordDict);
    dfs(s, 0, s.length() - 1);
    return res;
}
public void dfs(String s, int start, int end) {
    // 已经走到了末尾，添加结果
    if (start == end + 1) {
        String str = String.join(" ", path);
        res.add(str);
        return;
    }
    for (int i = start; i <= end; i++) {
        // dfs每个匹配结果
        if (set.contains(s.substring(start, i + 1))) {
            // 找到一个单词，从下一位继续查找
            path.add(s.substring(start, i + 1));
            dfs(s, i + 1, end);
            // 回溯
            path.remove(path.size() - 1);
        }
    }
}
```



## 【152】、乘积最大子数组

```java
/*
	动态规划
	o(n)
	o(1)
*/
public int maxProduct(int[] nums) {
    // max为以第i个数结尾的乘积最大的连续子序列
    int max = Integer.MIN_VALUE, iMax = 1, iMin = 1;
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] < 0) {
            // 出现负数，交换iMax和iMin，因为此时乘负数的话，阶段最小值iMin就变为阶段最大值iMax了，阶段最大值iMax就变成阶段最小值iMin了
            int tmp = iMax;
            iMax = iMin;
            iMin = tmp;
        }
        // 当前最大值iMax是乘完之后的值和不乘的值的最大值
        iMax = Math.max(iMax * nums[i], nums[i]);
        // 因为存在负数，会让最大值变为最小值，最小值变为最大值，所以要维护当前最小值，
        iMin = Math.min(iMin * nums[i], nums[i]);
        max = Math.max(max, iMax);
    }
    return max;
}
```



## 【153】、寻找旋转排序数组中的最小值

```java
/*
    大于右边，最小值在右边，收缩左边 mid + 1
    小于等于右边，最小值在左边，收缩右边 mid
    mid为区分，要么左边有序，要么y
    o(logn)
    o(1)
 */
public int findMin(int[] nums) {
    int left = 0;
    int right = nums.length - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        // 中间比右边大，最小值在右边，收缩左边
        if (nums[mid] > nums[right]) {
            left = mid + 1;
        } else {
            // 中间小于等于右边，一定在左边
            // 最小值在左边，收缩右边
            right = mid;
        }
    }
    return nums[left];
}
```

## 【162】、寻找峰值

```java
/*
    因为数组存在一个元素比相邻元素大，沿着它一定能找到一个峰值
    往上坡路走
    大于下一个，收缩右边，mid
    小于等于下一个，收缩左边，mid + 1
    o(logn)
    o(1)
 */
public int findPeakElement(int[] nums) {
    int left = 0;
    int right = nums.length - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        // 如果中间比右边大，峰顶就一定在左边，收缩右边，因为最左和最右都是最小，往左边是上坡
        if (nums[mid] > nums[mid + 1]) {
            right = mid;
        } else {
            // 否则收缩左边，峰顶在右边
            left = mid + 1;
        }
    }
    return left;
}
```



## 【167】、两数之和II-输入有序数组

```java
/*
   数组已经有序，双指针，返回下标+1
   o(n)    n是长度，最坏情况，left和right要移动n
   o(1)
*/
public int[] twoSum(int[] numbers, int target) {
    int left = 0;
    int right = numbers.length - 1;
    while (left < right) {
        int sum = numbers[left] + numbers[right];
        if (sum == target) {
            return new int[] {left + 1, right + 1};
        }
        if (sum > target) {
            --right;
        } else {
            ++left;
        }
    }
    return null;
}
```

## 【169】、多数元素

```java
/*
    众数，摩尔投票法，票数正负抵消，众数+1，非众数-1，若前a个数字票数和为0，则剩余票数和一定>0，剩余的众数仍是x
    所以尝试在票数和为0的时候缩小剩余数组区间
    如果考虑数组不存在众数的情况，就在最后重新遍历一次数组，判断x是不是众数
    核心思想--抵消原则： 在一个数组中，如果某个元素的出现次数超过了数组长度的一半，那么这个元素与其他所有元素一一配对，最后仍然会剩下至少一个该元素。 通过“投票”和“抵消”的过程，可以逐步消除不同的元素，最终留下的候选人就是可能的主要元素。
    o(n)
    o(1)
 */
public int majorityElement(int[] nums) {
    int x = 0;
    int votes = 0;
    for (int num : nums) {
        // 投票为0时，假设当前数就是众数
        if (votes == 0) {
            x = num;
        }
        votes += num == x ? 1 : -1;
    }
    return x;
}
```

## 【179】、最大数

```java
/*
	快速排序
	o(n*logn)
	o(n)
*/
public String largestNumber(int[] nums) {
    String[] strs = new String[nums.length];
    for (int i = 0; i < nums.length; i++) {
        strs[i] = String.valueOf(nums[i]);
    }
    // 降序排序，比如30和3对应a和b，a+b<b+a，所以a更小，排序后3在30之前
    // 如果返回负数，说明x更大，排在前面
    Arrays.sort(strs, (x, y) -> (y+x).compareTo(x+y));
    if (strs[0].equals("0")) {
        return "0";
    }
    StringBuilder res = new StringBuilder();
    for (String s : strs) {
        res.append(s);
    }
    return res.toString();
}
```



## 【189】、轮转数组

```java
/*
    o(n)    每个元素被翻转两次，一共n个元素，o(2n) = o(n)
    o(1)    
 */
public void rotate(int[] nums, int k) {
    int n = nums.length;
    k %= n;
    // 先整体翻转
    reverse(nums, 0, n - 1);
    // 前半部分翻转
    reverse(nums, 0, k - 1);
    // 后半部分翻转
    reverse(nums, k, n - 1);
}

public void reverse(int[] nums, int start, int end) {
    while (start < end) {
        int t = nums[start];
        nums[start] = nums[end];
        nums[end] = t;
        start++;
        end--;
    }
}
```

## 【198】、打家劫舍

```java
/*
    动态规划，dp[n + 1] = max(dp[n], dp[n - 1] + num)，多的一间房是偷和不偷的最大值
    o(n)
    o(1)
*/
public int rob(int[] nums) {
    int pre = 0; // 上上一个
    int cur = 0;
    int tmp = 0;
    for (int num : nums) {
        tmp = cur;
        // 要么偷(pre + num)要么不偷(cur)
        // 上一个，上上一个+num
        // 如第一天偷，第二天时，pre是0，不影响
        cur = Math.max(cur, pre + num);
        // 下一次的上上一个
        pre = tmp;
    }
    return cur;
}
```



## 【209】、长度最小的子数组

```java
/*
    o(n)    left和right最多各移动n次
    o(1)
 */
public int minSubArrayLen(int target, int[] nums) {
    int res = Integer.MAX_VALUE;
    int sum = 0;
    int length = nums.length;
    int left = 0;
    int right = 0;
    while(right < length){
        // 每次先加入右端点
        sum += nums[right];
        // 只要和>=目标，就收缩left
        while(sum >= target){
            res = Math.min(res, right - left + 1);
            sum -= nums[left];
            left++;
        }
        right++;
    }
    return res == Integer.MAX_VALUE ? 0 : res;
}
```

## 【215】、数组中第K个最大元素

### 解法1

分治

```java
/*
    分三个列表，不断递归
    o(n)    平均情况下，每次划分N+N/2+...+N/N=2N-1
    o(logN) 平均递归深度
*/
public int findKthLargest(int[] nums, int k) {
    List<Integer> numList = new ArrayList<>();
    for (int num : nums) numList.add(num);
    return quickSelect(numList, k);
}
private int quickSelect(List<Integer> nums, int k) {
    // 随机选择基础数
    Random rand = new Random();
    int p = nums.get(rand.nextInt(nums.size()));
    // 把大于、小于、等于p的元素划分到big, small, equal中.
    
    List<Integer> big = new ArrayList<>();
    List<Integer> equal = new ArrayList<>();
    List<Integer> small = new ArrayList<>();
    for (int num : nums) {
        if (num > p) {
            big.add(num);
        } else if (num < p) {
            small.add(num);
        } else {
            equal.add(num);
        }
    }
    // 第k大元素在big中，递归划分
    if (k <= big.size()) {
        return quickSelect(big, k);
    }
    // 第k大元素在small中，递归划分
    // k比大于等于基准值的数量都大，就一定在small
    if (nums.size() - small.size() < k) {
        // 在small里找的k是多出来的部分
        return quickSelect(small, k - (nums.size() - small.size()));
    }
    // 第k大元素在equal中，直接返回该元素
    return p;
}
```

### 解法2

优先队列 

```java
/*
	o(nlogk)，遍历o(n)，堆内元素调整o(logk)
	o(k)
*/
public int findKthLargest(int[] nums, int k) {
    int len = nums.length;
    // 使用一个含有 k 个元素的最小堆，PriorityQueue 底层是动态数组，为了防止数组扩容产生消耗，可以先指定数组的长度
    // 最小的元素you'xian'ji
    PriorityQueue<Integer> minHeap = new PriorityQueue<>(k, Comparator.comparingInt(a -> a));
    // Java 里没有 heapify ，因此我们逐个将前 k 个元素添加到 minHeap 里
    for (int i = 0; i < k; i++) {
        minHeap.offer(nums[i]);
    }

    for (int i = k; i < len; i++) {
        // 看一眼，不拿出，因为有可能没有必要替换
        Integer topElement = minHeap.peek();
        // 只要当前遍历的元素比堆顶元素大，堆顶弹出，遍历的元素进去
        if (nums[i] > topElement) {
            // Java 没有 replace()，所以得先 poll() 出来，然后再放回去
            minHeap.poll();
            minHeap.offer(nums[i]);
        }
    }
    return minHeap.peek();
}
```





## 【217】、存在重复元素

```java
/*
    o(n)
    o(n)
*/
public boolean containsDuplicate(int[] nums) {
    Set<Integer> set = new HashSet<Integer>();
    for (int x : nums) {
        if (!set.add(x)) {
            return true;
        }
    }
    return false;
}
```

## 【238】、除自身以外数组的乘积

```java
/*
    左部分乘积乘以右部分的乘积
    o(n)    两轮遍历数组
    o(1)
 */
public int[] productExceptSelf(int[] nums) {

    int n = nums.length;
    if (n == 0) {
        return new int[0];
    }
    int[] ans = new int[n];
    ans[0] = 1;
    int t = 1;
    // 先求左部分乘积
    for (int i = 1; i < n; i++) {
        ans[i] = ans[i - 1] * nums[i - 1];
    }
    // 从倒数第二个开始，因为倒数第一个只有左边乘积，已经计算过了
    for (int i = n - 2; i >= 0; i--) {
        t *= nums[i + 1];
        ans[i] *= t;
    }
    return ans;
}
```

## 【239】、滑动窗口最大值

```java
/*
    每次窗口移除nums[i - 1]，就要将窗口头等于该值的元素删除
    每次窗口增加nums[j + 1]，就要将窗口所有小于该值的元素删除
    o(n)    遍历o(n)，每个元素最多入队出队一次，单调队列o(2n)
    o(k)    双端队列最多同时存k个元素
    确保队列头部是当前窗口最大值
 */
public int[] maxSlidingWindow(int[] nums, int k) {
    int n = nums.length;
    if (n == 0 || k == 0) {
        return new int[0];
    }
    Deque<Integer> queue = new LinkedList<>();
    int[] res = new int[n - k + 1];
    // 未形成窗口
    for (int i = 0; i < k; i++) {
        while (!queue.isEmpty() && queue.peekLast() < nums[i]) {
            queue.removeLast();
        }
        queue.addLast(nums[i]);
    }
    res[0] = queue.peekFirst();
    // 形成窗口后
    for (int i = k; i < n; i++) {
        if (queue.peekFirst() == nums[i - k]) {
            // 上一个窗口的最大值和滑动后消失的最左侧值相同，则移除第一个
            queue.removeFirst();
        }
        while (!queue.isEmpty() && queue.peekLast() < nums[i]) {
            // 新加入的值比队列尾部的大，就移除队列尾部，因为当该值加入进去后，前面的其他值不可能是窗口最大值了
            queue.removeLast();
        }
        queue.addLast(nums[i]);
        res[i - k + 1] = queue.peekFirst();
    }
    return res;
}
```

## 【260】、只出现一次的数字III

```java
/*
	两次遍历，第一次确定两个数的异或和，之后获取异或和的最低位为1的值，对于该位，一定有x0和x1相与分别为0/1，确保同组内只有一个数出现一次
	o(n)
	o(1)
*/
public int[] singleNumber(int[] nums) {
    int ab = 0;
    for (int num : nums) {
        ab ^= num;
    }
    // -ab 相当于 (~ab) + 1
    int low = ab & -ab;
    int[] res = new int[2];
    for (int x : nums) {
        res[(x & low) == 0 ? 0 : 1] ^= x;
    }
    return res;
}
```



## 【283】、移动零

```java
/*
    o(n)    左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。
    左指针左边均为非零数；右指针左边直到左指针处均为零。因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。
    o(1)
 */
public void moveZeroes(int[] nums) {
    int left = 0;
    int right = 0;
    int n = nums.length;
    for (; right < n; right++) {
        if (nums[right] == 0) {
            continue;
        }
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
        left++;
    }
}
```

## 【287】、寻找重复数

```java
/*
	原地交换思想，每次让nums[i]=i
	o(n)
	o()
*/
public int findDuplicate(int[] nums) {
    int i = 0;
    while (i < nums.length) {
        if (nums[i] == i) {
            i++;
            continue;
        }
        // 第二次遇到，重复
        if (nums[nums[i]] == nums[i]) return nums[i];
        // 把数字交换到对应索引位置
        int t = nums[i];
        nums[i] = nums[t];
        nums[t] = t;
    }
    return -1;
}
```



## 【300】、最长递增子序列

```java
/*
	动态规划，
	o(n^2)
	o(n)
*/
public int lengthOfLIS(int[] nums) {
    if (nums.length == 0) return 0;
    // dp[i]为以nums[i]结尾的最长子序列长度
    int[] dp = new int[nums.length];
    int res = 0;
    Arrays.fill(dp, 1);
    for (int i = 0; i < nums.length; i++) {
        // 每次计算dp[i]，遍历[0,i)区间
        for (int j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                // i在j后面，此时是升序，更新dp[i]
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
        res = Math.max(res, dp[i]);
    }
    return res;
}

```



## 【322】、零钱兑换

```java
/*
	动态规划，每次计算凑成金额i所需最少的硬币个数
	
	o(n*m) n是amount，m是coins的长度
	o(n)	n是amount
*/
public int coinChange(int[] coins, int amount) {
    if (coins.length == 0) return -1;
    // dp[i]为凑成金额i所需的最少硬币个数
    int[] dp = new int[amount + 1];
    // 遍历每个金额
    for (int i = 1; i <= amount; i++) {
        // 凑成i最少硬币个数
        int min = Integer.MAX_VALUE;
        for (int j = 0; j < coins.length; j++) {
            // 如果可以用该硬币，同时用了之后凑成i的最少硬币个数更少，就更新最少硬币个数
            if (i - coins[j] >= 0 && dp[i - coins[j]] < min) {
                // 之前的再+1（用该硬币）
                min = dp[i - coins[j]] + 1;
            }
        }
        // 设置凑成i所需的最少硬币个数
        dp[i] = min;
    }
    return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
}
```



## 【347】、前K个高频元素、【LCR 060】

```java
/*
    o(nlogk)    堆操作o(logk)，遍历数组o(n)
    o(n)
 */
public int[] topKFrequent(int[] nums, int k) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int num : nums) {
        map.put(num, map.getOrDefault(num, 0) + 1);
    }
    // 小顶堆
    // 先加k个元素到堆，之后的元素要和堆顶（最小元素）对比，只有比堆顶次数多
    PriorityQueue<int[]> queue = new PriorityQueue<>((e1, e2) -> e1[1] - e2[1]);
    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
        int key = entry.getKey();
        int value = entry.getValue();
        if (queue.size() == k) {
            if (queue.peek()[1] < value) {
                queue.poll();
                queue.offer(new int[] {key, value});
            }
        } else {
            queue.offer(new int[] {key, value});
        }
    }
    int[] res = new int[k];
    for (int i = 0; i < k; i++) {
        res[i] = queue.poll()[0];
    }
    return res;
}
```



## 【403】、青蛙过河

```java
/*
        dp[i][k]表示青蛙是否能到i号石头且上次跳跃距离为k，如果dp[n-1][k]为真，就能到终点
        dp[i][k] = dp[j][k-1] || dp[i][j] || dp[j][k+1]
        j代表 stones[i] − stones[j] = k。
        o(n^2)  第i个石子后面有i-1个石子，每次o(1)计算是否可达
        o(n^2)  全部n^2个状态
     */
public boolean canCross(int[] stones) {
    int n = stones.length;
    boolean[][] dp = new boolean[n][n];
    dp[0][0] = true;
    // 当位置i和i-1的距离超过i，就必定无法到终点，因为每次跳跃距离最多+1，所以到位置i-1到位置i最多是i才有可能到终点
    for (int i = 1; i < n; i++) {
        if (stones[i] - stones[i - 1] > i) {
            return false;
        }
    }
    // 倒着模拟
    // 现在的位置
    for (int i = 1; i < n; i++) {
        // 枚举上一次的石子编号
        for (int j = i - 1; j >= 0; j--) {
            // 上一次从j到i的跳数
            int k = stones[i] - stones[j];
            // 下面有dp[j][k系列]，k最大是j+1，此时dp[j][j+1]，从j+1可以到j，限制
            if (k > j + 1) {
                break;
            }
            // 如果上一次距离是k-1、k、k+1之一就true
            // i是当前石子，j是上一个石子。判断上一个石子能不能跳到当前石子
            dp[i][k] = dp[j][k - 1] || dp[j][k] || dp[j][k + 1];
            // 为true代表为真
            if (dp[n - 1][k]) {
                return true;
            }
        }
    }
    return false;
}
```

## 【416】、分割等和子集

```java
/*
	动态规划
	o(n*target) target是整个数组的元素和的一半
	o(n*target)
*/
public boolean canPartition(int[] nums) {
    int n = nums.length;
    if (n < 2) return false;
    int sum = 0;
    int maxNum = 0;
    for (int num : nums) {
        sum += num;
        maxNum = Math.max(maxNum, num);
    }
    // 奇数直接返回
    if (sum %2 != 0) return false;
    int target = sum / 2;
    // 最大值比平均后的和大，直接返回
    if (maxNum > target) return false;
    // dp[i][j]表示从数组的[0,i]下标选若干个数，是否存在选到的和为j
    boolean[][] dp = new boolean[n][target + 1];
    for (int i = 0; i < n; i++) {
        dp[i][0] = true;
    }
    dp[0][nums[0]] = true;
    // 遍历所有元素
    for (int i = 1; i < n; i++) {
        int num = nums[i];
        for (int j = 1; j <= target; j++) {
            if (j >= num) {
                // 该num加入后可能可以合成j
                // 更新，没加之前可以合成j | 没加之前可以合成j-num，加了之后就合成j了
                dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num];
            } else {
                // 加入num后不可能合成j
                // 看没加之前能不能合成j
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[n - 1][target];
}
```



## 【442】、数组中重复的数据

```java
/*
	遍历数组，对于元素num，它对应的下标index=|num|-1，如果nums[index]>0，就把nums[index]更新为相反数，<0就说明|num|=index+1出现两次
	o(n)
	o(1)
	当一个整数被访问时，如果该整数对应的下标处的元素是正数，则该整数尚未被访问，因此将该整数对应的下标处的元素改成其相反数，相反数是负数，表示被访问了一次；
	当一个整数被访问时，如果该整数对应的下标处的元素是负数，则该整数已经被访问，因此该整数被第二次访问，即该整数是出现两次的整数。
*/
public List<Integer> findDuplicates(int[] nums) {
    List<Integer> duplicates = new ArrayList<Integer>();
    int n = nums.length;
    // 比如[2,1,2]
    // i=0时，num=2，index=1，此时2应该在1这个位置，nums[1]=1，此时让nums[1]=-1
    // i=1时，num=-1，index=0，此时1应该在0这个位置，nums[0]=2，此时让nums[0]=-2
    // i=2时，num=2，index=1，此时2应该在1这个位置，nums[1]=-1<0，说明2被die
    for (int i = 0; i < n; i++) {
        int num = nums[i];
        // 可能遍历到的元素已经是负数了，所以取绝对值
        int index = Math.abs(num) - 1;
        if (nums[index] > 0) {
            nums[index] = -nums[index];
        } else {
            duplicates.add(index + 1);
        }
    }
    return duplicates;
}
```

## 【485】、最大连续1的个数

```java
/*
	o(n)
	O(1)
*/
public int findMaxConsecutiveOnes(int[] nums) {
    int max = 0, count = 0;
    int n = nums.length;
    for (int i = 0; i < n; i++) {
        if (nums[i] == 1) {
            count++;
        } else {
            max = Math.max(max, count);
            count = 0;
        }
    }
    max = Math.max(max, count);
    return max;
}
```



## 【494】、目标和

回溯，没优化

```java
/*
	o(2^n)
	o(n)
*/
int ans = 0;
int[] nums;
public int findTargetSumWays(int[] nums, int target) {
    this.nums = nums;
    dfs(0,target);
    return ans;
}

private void dfs(int i,int target){
    if(i == nums.length){
        if(target == 0) {
            ans++;
        }
        return;
    }
    dfs(i + 1,target + nums[i]);
    dfs(i + 1,target - nums[i]);
}
```



## 【560】、和为k的子数组

```java
/*
    [j...i]这个子数组和为k，可以转换为   pre[i] - pre[j - 1] == k    即   pre[j - 1] == pre[i] - k
    统计以i结尾的和为k的连续子数组只要统计有多少个前缀和为 pre[i] - k的pre[j]
    o(n)    遍历数组o(n)，哈希表查询o(1)
    o(n)    哈希表最多n个不同键值
 */
public int subarraySum(int[] nums, int k) {
    int count = 0;
    int pre = 0;
    // 和为键，出现次数为值，
    HashMap<Integer, Integer> map = new HashMap<>();
    // 0出现次数1次
    map.put(0, 1);
    // 枚举起点
    for (int i = 0; i < nums.length; i++) {
        pre += nums[i];
        if (map.containsKey(pre - k)) {
            count += map.get(pre - k);
        }
        map.put(pre, map.getOrDefault(pre, 0) + 1);
    }
    return count;
}
```

## 【611】、有效三角形的个数

```java
/*
    先对数组排序，再固定最长的边，用双指针扫描
    o(n^2)
    o(logn)     排序
*/
public int triangleNumber(int[] nums) {
    Arrays.sort(nums);;
    int n = nums.length;
    int res = 0;
    // 枚举最大值，固定最长的边
    for (int i = n - 1; i >= 2; i++) {
        int l = 0;
        int r = i - 1;
        // 双指针指向另外两条边，只要nums[l] + nums[r] > nums[i]
        // 就说明nums[l + 1] + nums[r] > nums[i]...。满足条件的有r - l 种，r左移进入下一轮，找满足条件的l
        while (l < r) {
            if (nums[l] + nums[r] > nums[i]) {
                res += r - l;
                --r;
            } else {
                ++l;
            }
        }
    }
    return res;
}
```

## 【704】、二分查找

```java
/*
        前提升序、无重复元素
        o(log n)
        o(1)
*/
public int search(int[] nums, int target) {
    int l = 0;
    int r = nums.length - 1;
    while (l <= r) {
        int mid = l + (r - l) / 2;
        if (nums[mid] == target) {
            return mid;
        }
        if (target > nums[mid]) {
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    return -1;
}
```

## 【739】、每日温度

```java
/*
    如果一个下标在栈中，表示没找到下一次温度更高的下标
    o(n)    正向遍历一遍，每个下标最多一次进栈和出栈
    o(n)
 */
public int[] dailyTemperatures(int[] temperatures) {
    int length = temperatures.length;
    int[] ans = new int[length];
    Deque<Integer> stack = new LinkedList<>();
    for (int i = 0; i < length; i++) {
        int temperature = temperatures[i];
        // 当前元素是栈里比它小的元素的答案
        while (!stack.isEmpty() && temperature > temperatures[stack.peek()]) {
            int prevIndex = stack.pop();
            ans[prevIndex] = i - prevIndex;
        }
        stack.push(i);
    }
    return ans;
}
```



## 【746】、使用最小花费爬楼梯

```java
/*
    dp[i]只与dp[i-1]和dp[i-2]有关，滚动数组优化空间复杂度
    o(n)
    o(1)    滚动数组
*/
public int minCostClimbingStairs(int[] cost) {
    int n = cost.length;
    // 前两个位置花费0
    int pre = 0;
    int cur = 0;
    for (int i = 2; i <= n; i++) {
        // 上一个位置和上一个花费，上上一个位置和上上一个花费，取最小值
        int next = Math.min(cur + cost[i - 1], pre + cost[i - 2]);
        pre = cur;
        cur = next;
    }
    return cur;
}
```



## 【977】、有序数组的平方

```java
/*
        双指针，每次从最左和最右选平方后最大的放到最后
        o(n)
        o(1)
     */
public int[] sortedSquares(int[] nums) {
    int[] res = new int[nums.length];
    int r = nums.length - 1;
    int l = 0;
    int i = nums.length - 1;
    while (l <= r) {
        if (nums[l] * nums[l] > nums[r] * nums[r]) {
            res[i--] = nums[l] * nums[l];
            l++;
        } else {{
            res[i--] = nums[r] * nums[r];
            r--;
        }}
    }
    return res;
}
```

## 【1011】、在D天内到达包裹的能力

```java
/*
        船的运载能力进行二分
        o(nlog(和))  n是weights数组长度，和是数组重量之和
        o(1)
*/
public int shipWithinDays(int[] weights, int days) {
    // 最小运载能力，最大重量
    int l = 0;
    // 最大运载能力，重量之和
    int r = 0;
    for (int weight : weights) {
        l = Math.max(l, weight);
        r += weight;
    }
    while (l < r) {
        int mid = (l + r) / 2;
        // 需要运送的天数
        int day = 1;
        // 当前已经运送包裹重量和
        int cur = 0;
        for (int weight : weights) {
            if (cur + weight > mid) {
                // 当天超重，新加1天
                day++;
                cur = 0;
            }
            // 继续加
            cur += weight;
        }
        if (day <= days) {
            // 需要运送天数在目标天数之内，往左缩
            r = mid;
        } else {
            // 往右缩
            l = mid + 1;
        }
    }
    return l;
}
```

## 面试题、17.14、最小k个数

```java
/*
	大顶堆
	o(nlogk)	建堆复杂度o(nlogk)	构造答案复杂度o(klogk)
	o(k)		
	如果使用小顶堆，空间复杂度就是o(n+k)，时间复杂度就是o(nlogn)	建堆复杂度o(nlogn)	构造答案复杂度(klogk)
*/
public int[] smallestK(int[] arr, int k) {
    // 大顶堆
    PriorityQueue<Integer> q = new PriorityQueue<>((a,b)->b-a);
    int[] ans = new int[k];
    if (k == 0) return ans;
    for (int i : arr) {
        // 如果容量够同时最大值比i小，就继续，因为i不可能是最小的k个数
        if (q.size() == k && q.peek() <= i) continue;
        // 如果容量够同时最大值比i大，此时i一定是最小的k个数，出堆顶
        if (q.size() == k) q.poll();
        // 添加
        q.add(i);
    }
    // 
    for (int i = 0; i < k; i++) ans[i] = q.poll();
    return ans;
}
```



# 二维数组

## 【48】、旋转图像

```java
/*
    o(n2)
    o(1)
 */
public void rotate(int[][] matrix) {
    int n = matrix.length;
    // 水平翻转，枚举上半部分元素和下半部分元素交换
    for (int i = 0; i < n / 2; i++) {
        for (int j = 0; j < n; j++) {
            int t = matrix[i][j];
            matrix[i][j] = matrix[n - i - 1][j];
            matrix[n - i - 1][j] = t;
        }
    }
    // 主对角线翻转，枚举对角线左侧的元素和右侧元素交换
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < i; j++) {
            int t = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = t;
        }
    }
}
```

## 【54】、螺旋矩阵

```java
/*
    while(true)，每次for完就判断
    o(mn)   m，n分别为矩阵行数和列数
    o(1)    四个边界
 */
public List<Integer> spiralOrder(int[][] matrix) {

    int top = 0;
    int down = matrix.length - 1;
    int left = 0;
    int right = matrix[0].length - 1;

    List<Integer> res = new ArrayList<>();
    while (true) {
        for (int i = left; i <= right; i++) {
            res.add(matrix[top][i]);
        }
        if (++top > down) break;
        for (int i = top; i <= down; i++) {
            res.add(matrix[i][right]);
        }
        if (--right < left) break;
        for (int i = right; i >= left; i--) {
            res.add(matrix[down][i]);
        }
        if (--down < top) break;
        for (int i = down; i >= top; i--) {
            res.add(matrix[i][left]);
        }
        if (++left > right) break;
    }
    return res;
}
```

## 【56】、合并区间

```java
/*
    先排序，之后遍历数组，迭代赋值
    o(nlogn)    排序
    o(logn)     排序
 */
public int[][] merge(int[][] intervals) {
    // 先按照起始位置升序排序
    Arrays.sort(intervals, (v1, v2) -> v1[0] - v2[0]);
    int[][] res = new int[intervals.length][2];
    int idx = -1;
    // 遍历数组
    for (int[] nums : intervals) {
        // 对于当前数组，如果是空（刚开始）或者当前数组起始位置 > 结果数组中最后区间的位置
        // 就不进行合并，直接加入结果
        if (idx == -1 || nums[0] > res[idx][1]) {
            res[++idx] = nums;
        } else {
            // 合并，让结果数组右区间变为右区间最大值，因为可能当前数组都在上一个区间之内，所以尽管当前开头小于上一个的尾，
            // 也不能认为当前尾部小于上一个的尾
            res[idx][1] = Math.max(res[idx][1], nums[1]);
        }
    }
    return Arrays.copyOf(res, idx + 1);
}
```

## 【64】、最小路径和

```java
/*
	动态规划
	o(m*n)
	o(1)
*/
public int minPathSum(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (i == 0 && j == 0) {
                continue;
            } else if (i == 0) {
                // 只能从左边
                grid[i][j] += grid[i][j - 1];
            } else if (j == 0) {
                // 只能从右边
                grid[i][j] += grid[i - 1][j];
            } else {
                // 从最小的一边
                grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
            }
        }
    }
    return grid[m - 1][n - 1];
}
```



## 【73】、矩阵置零

```java
/*
    用矩阵的第一行和第一列代替两个标记数组（标识每一行或每一列有没有0），但这样原数组第一行和第一列会被修改，所以使用两个变量记录第一行和第一列原本是否包含0
    用第一行第一列代替标记数组，标记他们是否本来包含0，用其他行列去处理第一行和第一列，然后用第一行和第一列去更新其他列，
    最后用两个标记变量更新第一行和第一列
    o(mn)   m行n列
    o(1)
 */
public void setZeroes(int[][] matrix) {
    int m = matrix.length;
    int n = matrix[0].length;

    boolean flagCol0 = false, flagRow0 = false;
    for (int i = 0; i < m; i++) {
        if (matrix[i][0] == 0) {
            flagCol0 = true;
        }
    }
    for (int j = 0; j < n; j++) {
        if (matrix[0][j] == 0) {
            flagRow0 = true;
        }
    }

    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            if (matrix[i][j] == 0) {
                matrix[i][0] = matrix[0][j] = 0;
            }
        }
    }
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                matrix[i][j] = 0;
            }
        }
    }
    if (flagCol0) {
        for (int i = 0; i < m; i++) {
            matrix[i][0] = 0;
        }
    }
    if (flagRow0) {
        for (int j = 0; j < n; j++) {
            matrix[0][j] = 0;
        }
    }
}
```

## 【74】、搜索二维矩阵

```java
/*
    将矩阵每一行拼接在上一行的末尾，就得到一个升序数组，在该数组上进行一次二分，二分升序数组下标然后映射到行和列
    小于target，收缩左边，mid + 1
    大于target，收缩右边，mid - 1
    等于target，返回true
    o(logmn)    二分
    o(1)
 */
public boolean searchMatrix(int[][] matrix, int target) {
    int m = matrix.length;
    int n = matrix[0].length;
    int low = 0;
    int high = m * n - 1;	
    while (low <= high) {
        int mid = (high - low) / 2 + low;
        // /n是行，%n是列
        int x = matrix[mid / n][mid % n];
        if (x < target) {
            low = mid + 1;
        } else if (x > target) {
            high = mid - 1;
        } else {
            return true;
        }
    }
    return false;
}
```



## 【79】、单词搜索

```java
/*
    o(3^k MN)    最差情况，遍历矩阵长度为k字符串的所有方案，o(3^k)，每次找3个方向，从一个起点找k次，有MN个起点，o(MN)
    o(k)         递归深度，最坏情况递归深度是MN
 */
public boolean exist(char[][] board, String word) {
    char[] words = word.toCharArray();
    for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[0].length; j++) {
            if (dfs(board, words, i, j, 0)) return true;
        }
    }
    return false;
}
private boolean dfs(char[][] board, char[] word, int i, int j, int k) {
    // 如果越界或者不符合字符，false
    if (i >= board.length || i < 0 || j >= board[0].length || j < 0 || board[i][j] != word[k]) return false;
    // 符合就dfs，所以k到最后一个代表都找到了
    if (k == word.length - 1) return true;
    // 回溯，先标记
    board[i][j] = '#';
    boolean res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) ||
                  dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i, j - 1, k + 1);
    // 回溯归来
    board[i][j] = word[k];
    return res;
}
```



## 【200】、岛屿数量

```java
/*
   o(m*n)  虽然外循环o(m*n)，内有dfs，但dfs的递归最多遍历整个二维字符数组，最坏全为1，dfs只调用常数
   o(m*n)  最坏情况都是1
*/
public int numIslands(char[][] grid) {
    int count = 0;
    for(int i = 0; i < grid.length; i++) {
        for(int j = 0; j < grid[0].length; j++) {
            if(grid[i][j] == '1'){
                dfs(grid, i, j);
                count++;
            }
        }
    }
    return count;
}
public void dfs(char[][] grid, int i, int j){
    if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == '0') return;
    // 将遍历过的地方修改为0，避免之后重复搜索相同岛屿
    grid[i][j] = '0';
    dfs(grid, i + 1, j);
    dfs(grid, i, j + 1);
    dfs(grid, i - 1, j);
    dfs(grid, i, j - 1);
}
```

## 【207】、课程表

```java
/*
        拓扑排序判断是否是有向无环图，原理：对顶点排序，每条有向边(u,v)，均有u在v前出现
        如果是有向无环图（可以安排），则所有结点一定都入队并出队过，即完成拓扑排序，或者说如果图中存在环，一定有结点的入度始终不为0
        o(n + m) n为结点数量，m为临边数量
        o(n + m) 建立邻接表
    */
public boolean canFinish(int numCourses, int[][] prerequisites) {
    int[] in = new int[numCourses];
    // 邻接表
    List<List<Integer>> adj = new ArrayList();
    Queue<Integer> queue = new LinkedList();
    for (int i = 0; i < numCourses; i++) {
        adj.add(new ArrayList());
    }
    for (int[] cp : prerequisites) {
        in[cp[0]]++;
        adj.get(cp[1]).add(cp[0]);
    }
    // 将入度为0的结点入队
    for (int i = 0; i < numCourses; i++) {
        if (in[i] == 0) queue.add(i);
    }
    while (!queue.isEmpty()) {
        // 删除pre结点：将该结点对应所有邻接结点cur的入度-1
        int pre = queue.poll();
        numCourses--;
        for (int cur : adj.get(pre)) {
            if (--in[cur] == 0) queue.add(cur);
        }
    }
    return numCourses == 0;
}
```



## 【221】、最大正方形

```java
/*
	动态规划
	o(mn)	遍历每个元素计算dp
	o(mn)
*/
public int maximalSquare(char[][] matrix) {
    int maxSide = 0;
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
        return maxSide;
    }
    int rows = matrix.length, columns = matrix[0].length;
    // dp[i][j]表示以(i,j)为右下角，且只包含1的正方形边长最大值，计算所有dp[i][j]
    int[][] dp = new int[rows][columns];
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < columns; j++) {
            // 如果该位置是0，则dp[i][j]=0，因为当前位置不可能在由1组成的正方形中
            // 如果是1，则dp[i][j]的值由上方、左上方、左方的dp决定，最小值+1
            if (matrix[i][j] == '1') {
                if (i == 0 || j == 0) {
                    dp[i][j] = 1;
                } else {
                    dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                }
                maxSide = Math.max(maxSide, dp[i][j]);
            }
        }
    }
    int maxSquare = maxSide * maxSide;
    return maxSquare;
}
```



## 【240】、搜索二维矩阵II

```java
/*
    从左下角开始，比当前大就j++，比当前小就i--
    o(m + n)    最多循环行和列的次数
    o(1)
 */
public boolean searchMatrix(int[][] matrix, int target) {

    int m = matrix.length;
    int n = matrix[0].length;
    int i = m - 1;
    int j = 0;

    while (i >= 0 && j <= n - 1) {
        if (matrix[i][j] == target) {
            return true;
        }
        if (target > matrix[i][j]) {
            j++;
        } else {
            i--;
        }
    }
    return false;
}
```

## 【994】、腐烂的橘子

```java
/*
	bfs，先找出所有腐烂的橘子，再模拟腐烂过程
	o(mn)
	o(mn)
*/
public int orangesRotting(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    Queue<int[]> queue = new LinkedList();

    int count = 0; // 新鲜橘子数量
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == 1) {
                count++;
            } else if (grid[i][j] == 2) {
                // 腐烂橘子加入队列
                queue.offer(new int[]{i, j});
            }
        }
    }

    int round = 0; // 腐烂分钟数
    while (count > 0 && !queue.isEmpty()) {
        round++;
        int length = queue.size();
        for (int i = 0; i < length; i++) {
            int[] orange = queue.poll();
            int r = orange[0];
            int c = orange[1];
            if (r - 1 >= 0 && grid[r - 1][c] == 1) {
                // 如果坏橘子上面是好橘子
                grid[r - 1][c] = 2;
                count--;
                queue.offer(new int[]{r - 1, c});
            }
            if (r + 1 < m && grid[r + 1][c] == 1) {
                grid[r + 1][c] = 2;
                count--;
                queue.offer(new int[]{r + 1, c});
            }
            if (c - 1 >= 0 && grid[r][c - 1] == 1) {
                grid[r][c - 1] = 2;
                count--;
                queue.offer(new int[]{r, c - 1});
            }
            if (c + 1 < n && grid[r][c + 1] == 1) {
                grid[r][c + 1] = 2;
                count--;
                queue.offer(new int[]{r, c + 1});
            }
        }
    }
    if (count > 0) {
        return -1;
    }
    return round;
}
```

## 【1024】、视频拼接

```java
/*
        所有左端点相同的子区间，右端点越远越好，所以每个位置i只记录以其为左端点的子区间中最远的右端点max[i]
        每次用max[i]更新last，当last == i时说明下一个位置无法被覆盖
        同时记录上一个被使用的子区间的结束位置pre，每次越过一个被使用的子区间，就说明要启用一个新子区间，新子区间结束位置就是当前last
        即i == pre，就说明用完了一个被使用的子区间，让答案+1，更新pre
        o(time + n)     n是子区间长度，time是区间长度
        o(time)         记录每个位置为左端点的子区间的最右端点
*/
public int videoStitching(int[][] clips, int time) {
    int[] max = new int[time];
    // last == i说明下一个位置无法被覆盖
    int last = 0;
    // pre == i说明用完了一个被使用的子区间
    int pre = 0;
    int res = 0;
    for (int[] clip : clips) {
        // 位置i就是clip[0]
        // 如果区间左边在time内，更新位置i能到达的最远位置
        if (clip[0] < time) {
            max[clip[0]] = Math.max(max[clip[0]], clip[1]);
        }
    }
    for (int i = 0; i < time; i++) {
        // 获取当前可以到达的最远位置
        last = Math.max(last, max[i]);
        if (i == last) {
            // 下一个位置无法被覆盖
            return -1;
        }
        if (i == pre) {
            // 用完了一个被使用的区间
            res++;
            pre = last;
        }
    }
    return res;
}
```





# 单变量

## 【3】、无重复字符的最长子串

```java
/*
	每次计算以当前下标为结尾时，无重复字符的最长字串长度
   o(n)    
   o(1)    ascll范围0-127
*/
public int lengthOfLongestSubstring(String s) {
    // 哈希表统计字符s[j]最后一次出现的下标
    Map<Character, Integer> map = new HashMap();
    int i = -1;
    char[] strs = s.toCharArray();
    int res = 0;
    for (int j = 0; j < strs.length; j++) {
        // 如果重复出现s[j]，说明重复，计算i是靠右的
        if (map.containsKey(strs[j])) {
            i = Math.max(i, map.get(strs[j]));// 更新左指针 i
        }
        // 更新s[j]的最后一次出现下标
        map.put(strs[j], j);// 哈希表记录
        // 更新结果
        res = Math.max(res, j - i);
    }
    return res;
}
```

## 【5】、最长回文子串

```java
/*
	动态规划
	o(n^2)
	o(n^2)
*/
public String longestPalindrome(String s) {
    int n = s.length();
    if (n < 2) return s;
    int maxLen = 1;
    int start = 0;
    // dp[i][j]表示s[i,j]是否是回文串
    // dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]
    boolean[][] dp = new boolean[n][n];
    char[] chars = s.toCharArray();
    for (int i = 0; i < n; i++) dp[i][i] = true;
    for (int j = 1; j < n; j++) {
        for (int i = 0; i < j; i++) {
            if (chars[i] != chars[j]) {
                // 快速判断不是回文串
                dp[i][j] = false;
            } else {
                if (j - i < 3) {
                    dp[i][j] = true;
                } else {
                    dp[i][j] = dp[i + 1][j - 1];
                }
            }

            if (dp[i][j] && j - i + 1 > maxLen) {
                maxLen = j - i + 1;
                start = i;
            }
        }
    }
    return s.subString(start, start + maxLen);
}
```



## 【8】、字符串转换整数（atoi）；LCR192

```java
/*
    o(n)
    o(1)
    2147483647
*/
public int myAtoi(String s) {
    int res = 0;
    int limit = Integer.MAX_VALUE / 10;
    int i = 0;
    int sign = 1;
    int n = s.length();
    if (n == 0) return 0;
    // 排除开头空格
    while (s.charAt(i) == ' ') {
        // 如果到达末尾
        if (++i == n) {
            return 0;
        }
    }
    if (s.charAt(i) == '-') sign = -1;
    // 是符号就向前跳
    if (s.charAt(i) == '-' || s.charAt(i) == '+') i++;
    for (int j = i; j < n; j++) {
        // 非数字，直接跳出
        if (s.charAt(j) < '0' || s.charAt(j) > '9') break;
        // 如果超出限制，返回最大或最小值
        if (res > limit || (res == limit && s.charAt(j) > '7')) {
            return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
        }
        res = res * 10 + (s.charAt(j) - '0');
    }
    return sign * res;
}
```

## 【17】、电话号码的字母组合

```java
/*
    o(n*4^n)    最坏情况每次枚举4个字母，一共递归4^n次，加入答案需要o(n)
    o(n)
 */
static Map<Character, String> map = new HashMap<>();
static {
    map.put('2',"abc");
    map.put('3',"def");
    map.put('4',"ghi");
    map.put('5',"jkl");
    map.put('6',"mno");
    map.put('7',"pqrs");
    map.put('8',"tuv");
    map.put('9',"wxyz");
}
List<String> res = new ArrayList<>();
StringBuilder path = new StringBuilder();
char[] chars;
public List<String> letterCombinations(String digits) {
    if(digits == null || digits.length() == 0){
        return res;
    }
    this.chars = digits.toCharArray();
    dfs(0);
    return res;
}
private void dfs(int index) {
    if(index == chars.length){
        res.add(path.toString());
        return;
    }
    String choices = map.get(chars[index]);
    for(int i = 0;i < choices.length();i++){
        path.append(choices.charAt(i));
        dfs(index + 1);
        path.deleteCharAt(path.length()-1);
    }
}
```



## 【20】、有效的括号

```java
/*
    o(n)
    o(n + ∣Σ∣)  Σ表示字符集，为哈希表使用空间，n表示栈中的字符数量
 */
public boolean isValid(String s) {

    // 保存左括号的映射
    Map<Character,Character> map = new HashMap<Character,Character>(){{
        put('{', '}');
        put('[', ']');
        put('(', ')');
        put('z', 'z');
    }};
    int n = s.length();

    Stack<Character> stack = new Stack<>();
    // 如果第一个就是右括号，要保证栈里有元素
    stack.push('z');
    for (int i = 0; i < n; i++) {
        // 拿到当前字符
        char c = s.charAt(i);
        // 如果是左括号，就添加
        if (map.containsKey(c)) {
            stack.addLast(c);
        } else {
            // 当前c是右括号，拿到上一个左括号，去map找对应的右括号，和当前的右括号比对，不同就说明不匹配
            Character left = stack.pop();
            if (map.get(left) != c) {
                return false;
            }
        }
    }
    // 1表示只剩z
    return stack.size() == 1;
}
```

## 【22】、括号生成

```java
/*
    枚举是左括号还是右括号
    o(n*C(2n, n))      路径长度*搜索树叶子树
    o(n)
 */
int n;
StringBuilder path = new StringBuilder();
List<String> ans = new ArrayList<>();
public List<String> generateParenthesis(int n) {
    this.n = n;
    // 一共填2n个
    dfs(0, 0);
    return ans;
}
void dfs(int i, int left) {
    // 到头，一半左括号，一半右括号
    if (i == n * 2) {
        ans.add(path.toString());
        return;
    }
    // 每次都可以填左括号或右括号，可以先试试左括号，再试试右括号
    // 可以填左括号
    if (left < n) {
        path.append('(');
        dfs(i + 1, left + 1);
        path.deleteCharAt(path.length() - 1);
    }
    // 右括号数量少（i-left就是右括号数量），可以填右括号
    if (i - left < left) {
        path.append(')');
        dfs(i + 1, left);
        path.deleteCharAt(path.length() - 1);
    }
}
```

## 【32】、最长有效括号

### 贪心

```java
/*
        贪心，以当前字符下标结尾的有效括号长度。从左往右遍历，
        左右括号相同就记录，右括号多就归0，但没考虑左括号数量大于右括号，所以再从右往左遍历
        o(n)
        o(1)
*/
public int longestValidParentheses(String s) {
    int left = 0, right = 0, res = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '(') {
            left++;
        } else {
            right++;
        }
        // 左右括号相同时，计算当前有效字符串长度
        if (left == right) {
            res = Math.max(res, 2 * right);
        } else if (right > left) {
            // 右括号多，同时变为0
            left = right = 0;
        }
    }
    left = right = 0;
    for (int i = s.length() - 1; i >= 0; i--) {
        if (s.charAt(i) == '(') {
            left++;
        } else {
            right++;
        }
        if (left == right) {
            res = Math.max(res, 2 * left);
        } else if (left > right) {
            left = right = 0;
        }
    }
    return res;
}
```

### 栈

```java
/*
	栈底始终是当前已经遍历过的元素中最后一个没有被匹配的右括号的下标
	o(n)
	o(n)
*/
public int longestValidParentheses(String s) {
    int maxans = 0;
    Stack<Integer> stack = new Stack<Integer>();
    stack.push(-1);
    for (int i = 0; i < s.length(); i++) {
        // 左括号入栈
        if (s.charAt(i) == '(') {
            stack.push(i);
        } else {
            // 右括号出栈
            stack.pop();
            if (stack.isEmpty()) {
                // 栈空，说明当前右括号没有匹配的右括号，更新最后一个没有匹配的右括号的下标
                stack.push(i);
            } else {
                // 当前右括号下标-栈顶元素就是以该右括号结尾的最长有效括号的长度
                maxans = Math.max(maxans, i - stack.peek());
            }
        }
    }
    return maxans;
}
```

## 【51】、n皇后

```java
/*
    如果在一个位置放元素，右上方向r+c是定值，左上方向r-c是定值，保存这些，判断斜线冲突o(1)
    o(n^2*n!)   最多有n!个叶子，每个叶子生成答案n^2，但实际叶子数没有那么多，n=9是有352种方案
    o(n)
 */
int n;
int[] col;
boolean[] path, d1, d2;
List<List<String>> ans = new ArrayList<>();
public List<List<String>> solveNQueens(int n) {
    this.n = n;
    // 第i行的皇后在第col[i]列
    col = new int[n];
    path = new boolean[n];
    // 行号r：0->n-1    列号c：0->n-1     最大r+c是2n-2，所以大小是2n-1
    d1 = new boolean[2 * n - 1]; // r + c
    d2 = new boolean[2 * n - 1]; // r - c
    dfs(0);
    return ans;
}

private void dfs(int r) {
    // 0-n-1都好了，返回结果
    if (r == n) {
        List<String> board = new ArrayList<>(n);
        for (int c : col) {
            char[] row = new char[n];
            Arrays.fill(row, '.');
            row[c] = 'Q';
            board.add(new String(row));
        }
        ans.add(board);
        return;
    }
    // 从第1列枚举的
    for (int c = 0; c < n; c++) {
        // 因为下标不能为负数，r - c是d2的可能是负数，为了让右上角r-c最小时为正
        int rc = r - c + n - 1;
        // 如果方位不冲突就尝试回溯，之前没选过，r+c和r-c也没选过
        if (!path[c] && !d1[r + c] && !d2[rc]) {
            // 选择r行皇后为c列
            col[r] = c;
            // 回溯，设置该位置和r+c和r-c为已选
            path[c] = d1[r + c] = d2[rc] = true;
            dfs(r + 1);
            // 恢复
            path[c] = d1[r + c] = d2[rc] = false;
        }
    }
}
```

## 【59】、螺旋矩阵II

```java
/*
        模拟，123，45，67，8，9
        o(n^2)
        o(1)
     */
public int[][] generateMatrix(int n) {
    int[][] res = new int[n][n];
    int count = 1;
    int l = 0, r = n - 1, t = 0, b = n - 1;
    while (count <= n*n) {
        for (int i = l; i <= r; i++) {
            res[t][i] = count++;
        }
        t++;
        for (int i = t; i <= b; i++) {
            res[i][r] = count++;
        }
        r--;
        for (int i = r; i >= l; i--) {
            res[b][i] = count++;
        }
        b--;
        for (int i = b; i >= t; i--) {
            res[i][l] = count++;
        }
        l++;
    }
    return res;
}
```



## 【69】、x的平方根

```java
/*
	返回结果的整数部分的平方一定 <= x，所以可以进行二分查找
	o(logx)	二分查找的次数
	o(1)
*/
public int mySqrt(int x) {
    int l = 0;
    int r = x;
    int res = -1;
    while (l <= r) {
        int mid = l + (r - l) / 2;
        if ((long)mid * mid <= x) {
            res = mid;
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    return res;
}
```

## 【70】、爬楼梯

```java
/*
	最后一步只能跳一节或两节
    f(n) = f(n - 1) + f(n - 2)
    f(0) = 1    f(1) = 1    f(2) = 2
    o(n)
    o(1)
 */
public int climbStairs(int n) {
    int a = 1;
    int b = 1;
    int sum = 0;
    // 循环n - 1次
    for (int i = 0; i < n - 1; i++) {
        sum = a + b;
        a = b;
        b = sum;
    }
    return b;
}
```

## 【93】、复原IP地址

```java
/*
	回溯
	复杂度不确定
	时间复杂度：在最坏情况下，该算法需要遍历所有可能的IP地址组合。假设输入字符串的长度为n，最坏情况下有O(3^n)种可能的IP地址组合，因此时间复杂度为O(3^n)。
	空间复杂度：在递归过程中，除了存储结果的List之外，主要消耗空间的是递归调用栈的空间。在最坏情况下，递归深度为n，因此空间复杂度为O(n)。
*/
List<String> result = new ArrayList<>();

public List<String> restoreIpAddresses(String s) {
    if (s.length() > 12) return result; // 算是剪枝了
    backTrack(s, 0, 0);
    return result;
}

// startIndex: 搜索的起始位置， pointNum:添加逗点的数量
private void backTrack(String s, int startIndex, int pointNum) {
    if (pointNum == 3) {// 逗点数量为3时，分隔结束
        // 判断第四段⼦字符串是否合法，如果合法就放进result中
        if (isValid(s,startIndex,s.length()-1)) {
            result.add(s);
        }
        return;
    }
    for (int i = startIndex; i < s.length(); i++) {
        if (isValid(s, startIndex, i)) {
            s = s.substring(0, i + 1) + "." + s.substring(i + 1);    //在str的后⾯插⼊⼀个逗点
            pointNum++;
            backTrack(s, i + 2, pointNum);// 插⼊逗点之后下⼀个⼦串的起始位置为i+2
            pointNum--;// 回溯
            s = s.substring(0, i + 1) + s.substring(i + 2);// 回溯删掉逗点
        } else {
            break;
        }
    }
}

// 判断字符串s在左闭⼜闭区间[start, end]所组成的数字是否合法
private Boolean isValid(String s, int start, int end) {
    if (start > end) {
        return false;
    }
    if (s.charAt(start) == '0' && start != end) { // 0开头的数字不合法
        return false;
    }
    int num = 0;
    for (int i = start; i <= end; i++) {
        if (s.charAt(i) > '9' || s.charAt(i) < '0') { // 遇到⾮数字字符不合法
            return false;
        }
        num = num * 10 + (s.charAt(i) - '0');
        if (num > 255) { // 如果⼤于255了不合法
            return false;
        }
    }
    return true;
}
```



## 【118】、杨辉三角

```java
/*
    o(numRows^2)    外循环numRows，内循环依次增到numRows - 2
    o(1)
 */
public List<List<Integer>> generate(int numRows) {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> prev = new ArrayList<>();
    for (int i = 1; i <= numRows; i++) {
        List<Integer> row = new ArrayList<>(i);
        if (i == 1) {
            row.add(1);
        } else if (i == 2) {
            row.add(1);
            row.add(1);
        } else {
            row.add(1);
            for (int j = 1; j <= i - 2; j++) {
                row.add(prev.get(j - 1) + prev.get(j));
            }
            row.add(1);
        }
        prev = row;
        res.add(row);
    }
    return res;
}
```

## 【131】、分割回文串

```java
/*
    枚举子串结束位置
    o(n*2^n)    n是s的长度，长度最多是逗号子集个数，o(2^n)，递归2^n次（每个逗号可以有也可以没有，所有的情况就是2^n）
                判断回文和加入答案o(n)
    o(n)
 */
List<List<String>> ans = new ArrayList<>();
List<String> path = new ArrayList<>();
String s;
public List<List<String>> partition(String s) {
    this.s = s;
    dfs(0);
    return ans;
}

private void dfs(int i) {
    // 如果开始位置是最后，无，此时path构建好了
    if (i == s.length()) {
        ans.add(new ArrayList<>(path));
        return;
    }
    // 枚举子串的结束位置
    for (int j = i; j < s.length(); j++) {
        // 如果是从开始位置到结束位置是回文，就回溯
        if (check(i, j)) {
            // 加入该子串
            path.add(s.substring(i, j + 1));
            // 递归下一个开始位置
            dfs(j + 1);
            // 去掉该子串
            path.remove(path.size() - 1);
        }
    }
}

boolean check(int left, int right) {
    while (left < right) {
        if (s.charAt(left++) != s.charAt(right--)) {
            return false;
        }
    }
    return true;
}
```

## 【214】、最短回文串

```java
/*
        o(n)    长度
        o(n)    长度
        求最短回文串，最长就是将逆转的字符串拼到前面，为了求最短，相当于求最长的回文前缀，找到回文前缀，就将之后的字符串逆转拼接到前面
        使用kmp找最长回文前缀，s和s的逆序s'，s'作为查询串，遍历到s'末尾时，如果匹配到s第i个字符，就说明s前i个和s'后i个相同
        先求next数组，记录的就是一个字符串的每个位置上，最长公共前后缀的长度，最后一项就是str最长公共前后缀的长度，即s最长回文前缀长度
        可以认为next[i]的意义是如果匹配不同，下一次从next[i]下标处开始匹配
*/
public static String shortestPalindrome(String s) {
    int n = s.length();
    int[] next = new int[n];
    Arrays.fill(next, -1);
    for (int i = 1; i < n; ++i) {
        int j = next[i - 1];
        // 不匹配就去next[j]下标找，直到下标为-1或者匹配
        // 不断回溯找最长匹配前缀
        while (j != -1 && s.charAt(j + 1) != s.charAt(i)) {
            j = next[j];
        }
        if (s.charAt(j + 1) == s.charAt(i)) {
            // 该i处不匹配就去j+1下标找
            next[i] = j + 1;
        }
    }
    int index = -1;
    // 从末尾向前遍历，查找最长回文前缀的结束索引
    for (int i = n - 1; i >= 0; --i) {
        while (index != -1 && s.charAt(index + 1) != s.charAt(i)) {
            index = next[index];
        }
        if (s.charAt(index + 1) == s.charAt(i)) {
            ++index;
        }
    }
    // 如果匹配到了最后index=n-1，就说明s本身就是回文串，后面添加就直接返回s
    // 否则前index字符就是最长公共前缀
    String add = (index == n - 1 ? "" : s.substring(index + 1));
    StringBuilder ans = new StringBuilder(add).reverse();
    ans.append(s);
    return ans.toString();
}
```

## 【279】、完全平方数

```java
/*
	动态规划，答案在[1,根号n]之内，比如找到12的
	11 + 1、8 + 4、3 + 9。
	dp[n] = Math.min(dp[n - j*j] + 1, dp[n])。上一个次数+j的平方后+1，或者不变，就可以到达最终结果，找最小值
	o(n*根号n) 
	o(n)
*/
public int numSquares(int n) {
    int[] dp = new int[n + 1];
    for (int i = 1; i <= n; i++) {
        dp[i] = Integer.MAX_VALUE;
        // 枚举平方
        for (int j = 1; j * j <= i; j++) {
            dp[i] = Math.min(dp[i - j * j] + 1, dp[i]);
        }
    }
    return dp[n];
}
```



## 【394】、字符串解码

```java
/*
    先入后出两个栈
    遇见右括号时，用保存的循环次数和当前res计算一个temp，加到保存的Res栈弹出的res后面
    o(n)    一次遍历
    o(n)
 */
public String decodeString(String s) {
    StringBuilder res = new StringBuilder();
    int multi = 0;
    Stack<Integer> stack_multi = new Stack<>();
    Stack<String> stack_res = new Stack<>();
    for (Character c : s.toCharArray()) {
        if (c == '[') {
            // 把循环次数和结果加入栈
            stack_multi.push(multi);
            stack_res.push(res.toString());
            // 重置
            multi = 0;
            res = new StringBuilder();
        } else if (c == ']') {
            // 添加循环次数个res
            StringBuilder tmp = new StringBuilder();
            int cur_multi = stack_multi.pop();
            for (int i = 0; i < cur_multi; i++) tmp.append(res);
            // 更新结果
            res = new StringBuilder(stack_res.pop() + tmp);
        } else if (c >= '0' && c <= '9') {
            multi = multi * 10 + c - '0';
        } else {
            res.append(c);
        }
    }
    return res.toString();
}
```

## 【509】、斐波那契数

```java
/*
	dp[0]=0,dp[1]=1
	dp[i+1]=dp[i]+dp[i-1]
*/
public int fib(int n) {
    int a = 0;
    int b = 1;
    int sum = 0;
    for(int i = 0; i < n; i++){
        sum = a + b;
        a = b;
        b = sum;
    }
    return a;
}
```



## 【763】、划分字母区间

```java
/*
    贪心找每个片段可能的最小结束下标
    o(n)    第一次遍历记录每个字母最后一次出现的下标，第二次遍历进行字符串划分
    o(Σ)    字符集，最大26
 */
public List<Integer> partitionLabels(String s) {
    // 保存每个字母最后出现下标
    int[] last = new int[26];
    int n = s.length();
    for (int i = 0; i < n; i++) {
        last[s.charAt(i) - 'a'] = i;
    }
    List<Integer> res = new ArrayList<>();
    int start = 0;
    int end = 0;
    for (int i = 0; i < n; i++) {
        // 每次更新右边界，保证之前都在一个片段
        end = Math.max(end, last[s.charAt(i) - 'a']);
        // 如果到边界了，就切割片段
        if (i == end) {
            res.add(end - start + 1);
            start = end + 1;
        }
    }
    return res;
}
```







# 多变量

## 【43】、字符串相乘

```java
/*
   o(m*n)  长度之积
   o(m+n)  计算结果
*/
public String multiply(String num1, String num2) {
    if (num1.equals("0") || num2.equals("0")) {
        return "0";
    }
    // 最大位数是两数位数之和
    int[] res = new int[num1.length() + num2.length()];
    // 竖式相乘，比如num1的第1位*num2的第0位，位数从左开始算，结果两位数的第1位在res的第1+0位，第2位在res的第i+0+1位
    for (int i = num1.length() - 1; i >= 0; i--) {
        int n1 = num1.charAt(i) - '0';
        for (int j = num2.length() - 1; j >= 0; j--) {
            int n2 = num2.charAt(j) - '0';
            // 个位的和是res的第i+j+1位和当前的和
            int sum = (res[i + j + 1] + n1 * n2);
            // 个位取余
            res[i + j + 1] = sum % 10;
            // 前一位进位
            res[i + j] += sum / 10;
        }
    }
    StringBuilder result = new StringBuilder();
    for (int i = 0; i < res.length; i++) {
        if (i == 0 && res[i] == 0) continue;
        result.append(res[i]);
    }
    return result.toString();
}
```

## 【62】、不同路径

```java
/*
	动态规划
	o(m*n)
	o(m*n) 下面有优化o(n)
*/
public int uniquePaths(int m, int n) {
    // dp[i][j]表示到达i,j的最多路径
    int[][] dp = new int[m][n];
    for (int i = 0; i < n; i++) dp[0][i] = 1;
    for (int i = 0; i < m; i++) dp[i][0] = 1;
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            // 要么是从上面，要么是从左面
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
}
// 优化空间复杂度为 o(n)，dp[i][j]只和第i行和第i-1行的状态有关系，所以用滚动数组代替二维数组
public int uniquePaths(int m, int n) {
    int[] dp = new int[n];
    for (int i = 0; i < n; ++i) {
        dp[i] = 1;
    }
    for (int i = 1; i < m; ++i) {
        for (int j = 1; j < n; ++j) {
            dp[j] += dp[j - 1];
        }
    }
    return dp[n - 1];
}

```

## 【72】、编辑距离

```java
/*
	动态规划，自底向上
	o(n*m)
	o(n*m)
*/
public int minDistance(String word1, String word2) {
    int n = word1.length();
    int m = word2.length();
    // dp[i][j]表示word1到i位置转换为word2到j位置需要的最少步数
    int[][] dp = new int[n + 1][m + 1];
    for (int i = 1; i <= n; i++) {
        //dp[i][0]：将 word1 的前 i 个字符转换为空字符串需要 i 步（删除操作）。
        dp[i][0] = dp[i - 1][0] + 1;
    }
    for (int j = 1; j <= m; j++) {
        //dp[0][j]：将空字符串转换为 word2 的前 j 个字符需要 j 步（插入操作）。
        dp[0][j] = dp[0][j - 1] + 1;
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                // 相等的时候，步数为前一个的最少步数
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                // 不等的时候，是前一个的三个可能性 + 1个操作
                // dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1
                // dp[i-1][j-1] 表示替换操作，dp[i-1][j] 表示删除操作，dp[i][j-1] 表示插入操作。
                // 比如word1 为 "horse"，word2 为 "ros"，dp[5][3]
                // dp[i-1][j-1]，把word1的前4个转为word2的前2个，再把最后一个替换
                // dp[i][j-1]，把word1的前5个转为word2的前2个，再给最后加入word2的最后一个s
                // dp[i-1][j]，把word1的前4个转为word2的前3个，再删除word1的最后一个e
                dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;
            }
        }
    }
    return dp[n][m];
}
```



## 【76】、最小覆盖子串

```java
/*
    滑动窗口
    right指针不断扩张窗口，当窗口包含t全部字符之后，判断如果可以收缩，就收缩窗口直到得到最小窗口
    o(n)    外循环o(n)，内循环最多执行n次（left最多移动n次）
    o(n)    map最多存储t中所有不同字符
 */

public String minWindow(String s, String t) {
    // 统计 t 中个字符出现的次数
    Map<Character, Integer> map = new HashMap<>();
    // 匹配t字符出现次数
    int len = t.length();
    // 曾经出现的最小长度
    int minLen = Integer.MAX_VALUE;
    String res = "";
    // 统计t中各字符出现个数
    for (int i = 0; i < len; i++) {
        char temp = t.charAt(i);
        map.put(temp, map.getOrDefault(temp, 0) + 1);
    }
    // 滑动窗口
    for (int left = 0, right = 0; right < s.length(); right++) {
        // 右指针字符
        char temp = s.charAt(right);
        if (map.containsKey(temp)) {
            // 如果当前字符在t中存在同时出现次数大于0，待匹配字符长度减1
            if (map.get(temp) > 0) {
                len--;
            }
            map.put(temp, map.get(temp) - 1);
        }
        while (len == 0) {
            // 出现最小值，更新minLen和res
            if (right - left + 1 < minLen) {
                minLen = right - left + 1;
                res = s.substring(left, right + 1);
            }
            temp = s.charAt(left);
            if (map.containsKey(temp)) {
                if (map.get(temp) >= 0) {
                    len++;
                }
                map.put(temp, map.get(temp) + 1);
            }
            left++;
        }
    }
    return res;
}
```

## 【77】、组合

```java
/*
    o(C(n,k)*k) 结果数*深度
    o(k)        递归深度
 */
List<List<Integer>> res = new ArrayList<>();
List<Integer> path = new ArrayList<>();
public List<List<Integer>> combine(int n, int k) {
    dfs(n, k, 1);
    return res;
}

private void dfs(int n, int k, int index) {
    if (path.size() == k) {
        res.add(new ArrayList(path));
        return;
    }
    // 起始位置最多到 n - (k - path.size()) + 1，+1是包括起始位置
    int length = n - (k - path.size()) + 1;
    for (int i = index; i <= length; i++){
        path.add(i);
        dfs(n, k, i + 1);
        path.remove(path.size() - 1);
    }
}
```

## 【165】、比较版本号

```java
/*
	双指针，分割版本号的同时解析出修订号进行比较
	o(m + n)
	o(1)
*/
public int compareVersion(String version1, String version2) {
    int n = version1.length(), m = version2.length();
    int i = 0, j = 0;
    while (i < n || j < m) {
        int x = 0;
        for (; i < n && version1.charAt(i) != '.'; ++i) {
            x = x * 10 + version1.charAt(i) - '0';
        }
        ++i; // 跳过点号
        int y = 0;
        for (; j < m && version2.charAt(j) != '.'; ++j) {
            y = y * 10 + version2.charAt(j) - '0';
        }
        ++j; // 跳过点号
        if (x != y) {
            return x > y ? 1 : -1;
        }
    }
    return 0;
}
```

## 【216】、组合总和III

```java
/*
    o(C(n, k)*k)
    o(k)    递归深度
 */
List<List<Integer>> res = new ArrayList<>();
List<Integer> path = new ArrayList<>();
public List<List<Integer>> combinationSum3(int k, int n) {
    dfs(k, n ,1);
    return res;
}
private void dfs(int k, int n, int now) {
    if (n < 0) return;
    if (path.size() == k){
        if (n == 0) {
            res.add(new ArrayList<>(path));
        }
        return;
    }
    for (int i = now; i <= 9; i++){
        path.add(i);
        dfs(k, n - i, i + 1);
        path.remove(path.size() - 1);
    }
}
```

## 【438】、找到字符串中所有字母异位词

```java
/*
	o(n + m + 可能字符数) 初始化窗口o(m)，初始化differo(26)，o(n-m)判断窗口内每种字母数量是否和字符串p中每种字母数量相同
	o(26)	存储cha
*/
public List<Integer> findAnagrams(String s, String p) {
    List<Integer> ans = new ArrayList<>();
    int m = s.length();
    int n = p.length();
    if (m < n) {
        return ans;
    }
    int[] cnt = new int[26];
    // s+  p-
    for (int i = 0; i < n; i++) {
        cnt[s.charAt(i) - 'a']++;
        cnt[p.charAt(i) - 'a']--;
    }
    // 维护数量不同字母的个数
    int differ = 0;
    for (int j = 0; j < 26; j++) {
        if (cnt[j] != 0) {
            ++differ;
        }
    }
    if (differ == 0) {
        ans.add(0);
    }
    // 每次都是 s[i]处字母没有了，s[i + n]处字母有了
    for (int i = 0; i < m - n; i++) {
        // 之前 s有   p没有，现在没了s
        if (cnt[s.charAt(i) - 'a'] == 1) {
            --differ;
        } else if (cnt[s.charAt(i) - 'a'] == 0) {
            // 之前s和p都有或都没有，但因为s已经有了，所以之前s和p都有，现在没了 s
            ++differ;
        }
        // s没有
        --cnt[s.charAt(i) - 'a'];

        // 之前 s没有   p有，现在有了s
        if (cnt[s.charAt(i + n) - 'a'] == -1) {
            differ--;
        } else if (cnt[s.charAt(i + n) - 'a'] == 0) {
            // 之前s和p都有或都没有，因为s已经有了，所以之前s和p都有，现在有了s
            ++differ;
        }
        ++cnt[s.charAt(i + n) - 'a'];

        if (differ == 0) {
           ans.add(i + 1);
        }
    }
    return ans;
}
```

## 【1143】、最长公共子序列

```java
/*
	动态规划
	o(n*m)
	o(n*m)
*/
public int longestCommonSubsequence(String text1, String text2) {
    int n = text1.length();
    int m = text2.length();
    // dp[i][j]表示text1的[1,i]和text2的[1,j]区间的最长公共子序列长度
    int[][] dp = new int[n + 1][m + 1];
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                // 两个字符串的最后一位相等，此时dp[i][j]为前一个区间的最长公共子序列长度+1
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                // dp[i][j]继承前一位的较大值
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[n][m];
}
```





# 设计

## 【146】、LRU缓存

双向链表+哈希

```java
class LRUCache {
    class Node {
        int key;
        int value;
        Node prev;
        Node next;
        public Node() {}
        public Node(int key, int value) {this.key = key; this.value = value;}
    }
    Map<Integer, Node> cache = new HashMap<>();
    int size;
    int capacity;
    Node head, tail;
    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        // 伪头部和伪尾部
        head = new Node();
        tail = new Node();
        head.next = tail;
        tail.prev = head;
    }
    
    // 添加到头部
    void addToHead(Node node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }
    // 移除节点
    void removeNode(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
    // 把节点移到头部   先移除，再添加到头部
    void moveToHead(Node node) {
        removeNode(node);
        addToHead(node);
    }
    
    public int get(int key) {
        Node node = cache.get(key);
        if (node == null) return -1;
        // key存在，先通过哈希表定位，再移到头部
        moveToHead(node);
        return node.value;
    }
    public void put(int key, int value) {
        Node node = cache.get(key);
        if (node == null) {
            // key不存在就创建新节点
            Node newNode = new Node(key, value);
            cache.put(key, newNode);
            // 添加到双向链表的头部
            addToHead(newNode);
            ++size;
            if (size > capacity) {
                // 超出容量，删除双向链表的尾部节点
                Node tail = removeTail();
                // 删除哈希表对应的项
                cache.remove(tail.key);
                --size;
            }
        } else {
            // key存在就先通过哈希表定位，再修改value移到头部
            node.value = value;
            moveToHead(node);
        }

    }

    // 移除尾部并返回
    Node removeTail() {
        Node res = tail.prev;
        removeNode(res);
        return res;
    }
}
```

## 【155】、最小栈

```java
/*
    o(n)    压栈、出栈、获取最小值都是o(1)
    o(n)
 */
class MinStack {

    Stack<Integer> stack;
    // 保证栈顶元素是最小元素，从栈底到栈
    Stack<Integer> min_stack;
    public MinStack() {
        stack = new Stack<>();
        min_stack = new Stack<>();
    }

    public void push(int val) {
        stack.push(val);
        if (min_stack.isEmpty() || val <= min_stack.peek()) {
            // 此时需要更新栈顶最小值
            min_stack.push(val);
        }
    }

    public void pop() {
        if (stack.pop().equals(min_stack.peek())) {
            // 最小栈只有在这种情况才会出栈，保证栈顶元素始终是最小值
            min_stack.pop();
        }
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return min_stack.peek();
    }
}
```

## 【208】、实现Trie(前缀树)

```java
class Trie {

    /*
        o(len) 时间复杂度取决于入参字符串长度
        o(nk) 结点数量n，字符集大小k
    */
    class TrieNode {
        boolean end;
        TrieNode[] tns = new TrieNode[26];
    }

    TrieNode root;
    public Trie() {
        root = new TrieNode();
    }
    
    public void insert(String word) {
        TrieNode p = root;
        for (int i = 0; i < word.length(); i++) {
            int u = word.charAt(i) - 'a';
            if (p.tns[u] == null) {
                p.tns[u] = new TrieNode();
            }
            p = p.tns[u];
        }
        p.end = true;
    }
    
    public boolean search(String word) {
        TrieNode p = root;
        for (int i = 0; i < word.length(); i++) {
            int u = word.charAt(i) - 'a';
            if (p.tns[u] == null) return false;
            p = p.tns[u];
        }
        return p.end;
    }
    
    public boolean startsWith(String prefix) {
        TrieNode p = root;
        for (int i = 0; i < prefix.length(); i++) {
            int u = prefix.charAt(i) - 'a';
            if (p.tns[u] == null) return false;
            p = p.tns[u];
        }
        return true;
    }
}
```

## 【225】、用队列实现栈

```java
/*
	入栈o(n)，出栈o(1)，n是栈内元素个数
	o(n)
*/
class MyStack {
    // 队列1是真正的栈，出栈是出队列1的头
    Queue<Integer> queue1;
    Queue<Integer> queue2;

   	// 构造器
    public MyStack() {
        queue1 = new LinkedList<Integer>();
        queue2 = new LinkedList<Integer>();
    }
    
    // 入栈
    /*
    	1入栈，q1：1	q2：
        2入栈，q1：2，1 q2:
    */
    public void push(int x) {
        queue2.offer(x);
        while (!queue1.isEmpty()) {
            queue2.offer(queue1.poll());
        }
        Queue<Integer> temp = queue1;
        queue1 = queue2;
        queue2 = temp;
    }
    
    // 出栈
    public int pop() {
        return queue1.poll();
    }
    
    public int top() {
        return queue1.peek();
    }
    
    // q1判断是否为空
    public boolean empty() {
        return queue1.isEmpty();
    }
}
```

## 【295】、数据流的中位数

```java
/*
	添加元素保持数组有序，二分查找插入时间复杂度o(logn)，使用堆优化
	A小顶堆保存较大的一半，B大顶堆保存较小的一半
	中位数根据AB堆顶元素计算，奇数返回小顶堆堆顶，偶数返回两个堆顶之和除2
	o(logn) 查找中位数o(1)，添加数字o(logn)
	o(n)
*/
class MedianFinder {
    Queue<Integer> A, B;
    public MedianFinder() {
        A = new PriorityQueue();
        B = new PriorityQueue<>((x, y) -> (y - x));
    }
    
    public void addNum(int num) {
        if (A.size() != B.size()) {
            // 奇数时给B插入，流程是先插A，再插B
            A.add(num);
            B.add(A.poll());
        } else {
            // 偶数时给A插入，流程是先插B(维持较小的元素都在B里)，再插A
            B.add(num);
            A.add(B.poll());
        }
    }
    
    public double findMedian() {
        return A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / 2.0;
    }
}
```

## 【303】、区域和检索-数组不可变

```java
/*
	前缀和
	o(n)
	o(n)
*/
class NumArray {
    int[] sums;

    public NumArray(int[] nums) {
        int n = nums.length;
        sums = new int[n + 1];
        for (int i = 0; i < n; i++) {
            sums[i + 1] = sums[i] + nums[i];
        }
    }
    
    public int sumRange(int i, int j) {
        return sums[j + 1] - sums[i];
    }
}
```



## 【707】、设计链表

```java
//双链表
class MyLinkedList {

    //记录链表中元素的数量
    int size;
    //记录链表的虚拟头结点和尾结点
    ListNode head,tail;

    public MyLinkedList() {
        //初始化操作
        this.size = 0;
        this.head = new ListNode(0);
        this.tail = new ListNode(0);
        //这一步非常关键，否则在加入头结点的操作中会出现null.next的错误！！！
        head.next=tail;
        tail.prev=head;
    }

    public int get(int index) {
        //判断index是否有效
        if(index<0 || index>=size){
            return -1;
        }
        ListNode cur = this.head;
        //判断是哪一边遍历时间更短
        if(index >= size / 2){
            //tail开始
            cur = tail;
            for(int i=0; i< size-index; i++){
                cur = cur.prev;
            }
        }else{
            for(int i=0; i<= index; i++){
                cur = cur.next;
            }
        }
        return cur.val;
    }

    public void addAtHead(int val) {
        //等价于在第0个元素前添加
        addAtIndex(0,val);
    }

    public void addAtTail(int val) {
        //等价于在最后一个元素(null)前添加
        addAtIndex(size,val);
    }

    public void addAtIndex(int index, int val) {
        //index大于链表长度
        if(index>size){
            return;
        }
        //index小于0
        if(index<0){
            index = 0;
        }
        size++;
        //找到前驱
        ListNode pre = this.head;
        for(int i=0; i<index; i++){
            pre = pre.next;
        }
        //新建结点
        ListNode newNode = new ListNode(val);
        newNode.next = pre.next;
        pre.next.prev = newNode;
        newNode.prev = pre;
        pre.next = newNode;

    }

    public void deleteAtIndex(int index) {
        //判断索引是否有效
        if(index<0 || index>=size){
            return;
        }
        //删除操作
        size--;
        ListNode pre = this.head;
        for(int i=0; i<index; i++){
            pre = pre.next;
        }
        pre.next.next.prev = pre;
        pre.next = pre.next.next;
    }
}
```



# 链表



## 【2】、两数相加

```java
/*
    o(max(m,n))
    o(1)
    模拟竖式加法，逐位相加并处理进位，用虚拟头节点（head）简化链表操作，短链表补零，最后检查进位即可
 */

public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode head = new ListNode();
    ListNode tail = head;
    int c = 0;
    while(l1 != null || l2 != null){
        int v1 = l1 == null ? 0 : l1.val;
        int v2 = l2 == null ? 0 : l2.val;
        int val = (v1 + v2 + c) % 10;
        c = (v1 + v2 + c) / 10;
        ListNode newNode = new ListNode(val);
        tail.next = newNode;
        tail = newNode;
        if(l1 != null){
            l1 = l1.next;
        }
        if(l2 != null){
            l2 = l2.next;
        }
    }
    if(c == 1){
        tail.next = new ListNode(1);
    }
    return head.next;
}
```

## 【19】、删除链表的倒数第N个结点

```java
/*
	快慢指针
    o(n)
    o(1)
 */
public ListNode removeNthFromEnd(ListNode head, int n) {

    ListNode h = new ListNode(0, head);
    // first和end都指向头
    ListNode first = h;
    ListNode end = h;
    // first向前走n步
    for (int i = 0; i < n; i++) {
        first = first.next;
    }
    // 每次走，first和end相差n步，当first的下一个为空时，说明first是最后一个
    // 此时first和end相差n步，end的下一个就是要删除的节点
    while (first.next != null) {
        first = first.next;
        end = end.next;
    }
    end.next = end.next.next;

    return h.next;
}
public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummynode = new ListNode(0);
        dummynode.next = head;

        ListNode fastIndex = dummynode;
        ListNode slowIndex = dummynode;

        for (int i = 0; i <= n; i++) {//快指针的n+1次移动是关键
            fastIndex = fastIndex.next;
        }

        while (fastIndex != null) {
            fastIndex = fastIndex.next;
            slowIndex = slowIndex.next;
        }

        slowIndex.next = slowIndex.next.next;
        return dummynode.next;
    }
```

## 【21】、合并两个有序链表

```java
/*
	o(m + n)
	o(1)
*/
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    ListNode node = new ListNode(0), cur = node;
    while (list1 != null && list2 != null) {
        if (list1.val < list2.val) {
            cur.next = list1;
            list1 = list1.next;
        }
        else {
            cur.next = list2;
            list2 = list2.next;
        }
        cur = cur.next;
    }
    cur.next = list1 != null ? list1 : list2;
    return node.next;
}
```

## 【23】、合并K个升序链表

```java
/*
	第一种
    分支合并
    o(n*m*logn)  递归层数logn，每一层递归需要合并的链表总数是n，每次递归合并的时间复杂度是o(m)，m是两个链表的平均长度
    o(logn)      递归栈深度
 */
public ListNode mergeKLists(ListNode[] lists) {
    return merge(lists, 0, lists.length - 1);
}

private ListNode merge(ListNode[] lists, int l, int r) {

    if (l == r) {
        return lists[l];
    }
    if (l > r) {
        return null;
    }
    int mid = l + (r - l) / 2;
    ListNode left = merge(lists, l, mid);
    ListNode right = merge(lists, mid + 1, r);
    return mergeTwoLists(left, right);
}

private ListNode mergeTwoLists(ListNode a, ListNode b) {

    if (a == null || b == null) {
        return a != null ? a : b;
    }
    ListNode head = new ListNode();
    ListNode tail = head;
    while (a != null && b != null) {
        if (a.val < b.val) {
            tail.next = a;
            a = a.next;
        } else {
            tail.next = b;
            b = b.next;
        }
        tail = tail.next;
    }
    tail.next = (a != null ? a : b);
    return head.next;
}

/*	
	第二种
    优先队列维护n个链表候选节点中的最小值
    o(kn*logn)  插入和删除时间代价o(logn)    n是链表数组的长度，k是链表中节点总数，while中o(nk)
    o(k)    优先队列元素不超过k个
*/
public ListNode mergeKLists(ListNode[] lists) {
    Queue<ListNode> pq = new PriorityQueue<>((o1, o2) -> o1.val - o2.val);     // 优先队列，根据节点值进行升序排序
    for(ListNode head : lists){
        if(head != null) pq.offer(head); // 初始将所有链表头节点入队
    }
    ListNode pre = new ListNode();  // 伪头节点
    ListNode node = pre;    // 当前合并链表的最后一个节点
    // 合并链表直到队列不为空
    while(!pq.isEmpty()){
        node.next = pq.poll();  // 从优先队列中弹出最小值节点作为合并链表的新节点
        node = node.next;   // 更新合并链表最后一个节点的指向，即为弹出的最小值节点
        if(node.next != null){
            pq.offer(node.next);    // 最小值节点还有后续节点，后续节点作为新的候选节点入队
        }
    }
    return pre.next;
}
```

## 【24】、两两交换链表中的节点

```java
/*
    1.递归
    o(n)    需要对每个节点进行更新操作
    o(n)    递归o(n/2)
 */
public ListNode swapPairs(ListNode head) {
    // 如果有一个或无节点，直接返回
    if (head == null || head.next == null) return head;

    // 第三个节点
    ListNode three = head.next.next;
    // 返回的新头是head.next
    ListNode res = head.next;
    // 新头的下一个是head
    res.next = head;
    // head的下一个是处理完第三个节点的头
    head.next = swapPairs(three);
    return res;
}

/*
    2.迭代
    以新头开始，每次迭代需要三个节点
    o(n)
    o(1)
 */
public ListNode swapPairs2(ListNode head) {
    ListNode H = new ListNode();
    H.next = head;
    ListNode temp = H;
    while (temp.next != null && temp.next.next != null) {
        ListNode n1 = temp.next;
        ListNode n2 = temp.next.next;
        temp.next = n2;
        n1.next = n2.next;
        n2.next = n1;
        temp = n1;
    }
    return H.next;
}
```

## 【25】、K个一组翻转链表

```java
/*
    o(n*k)  while循环次数取决于链表长度和k，每次循环都reverse(o(k))，总时间复杂度o(n*k)
    o(1)    常数变量
 */
public ListNode reverseKGroup(ListNode head, int k) {
    ListNode res = new ListNode();
    res.next = head;
    // pre指向每次翻转的头节点的上一个节点
    ListNode pre = res;
    // end指向每次翻转链表的尾节点
    ListNode end = res;
    // 尾节点的下一个不为空
    while (end.next != null) {
        // 每次找到需要翻转的链表的结尾，如果end是空，end.next会空指针
        for (int i = 0; i < k && end != null; i++) {
            end = end.next;
        }
        // 要翻转的链表的节点数小于k，不翻转
        if (end == null) {
            break;
        }
        // 先记录end.next
        ListNode next = end.next;
        // 断开链表
        end.next = null;
        // 记录翻转链表的头节点
        ListNode start = pre.next;
        // 翻转链表，pre.next指向翻转后的链表
        pre.next = reverse(start);
        // 翻转后的头节点变为最后节点，连接后面的节点
        start.next = next;
        // 将pre变为下一次翻转的头节点的上一个节点，start
        pre = start;
        // 翻转结束，将end置为下一次翻转的链表的头节点的上一个节点，start
        end = start;
    }
    return res.next;
}

public ListNode reverse(ListNode head) {
    ListNode cur = head;
    ListNode pre = null;
    while (cur != null) {
        // 将当前节点的下一个指向之前节点，先保存后继节点
        ListNode t = cur.next;
        // 当前节点的上一个指向之前节点
        cur.next = pre;
        // 之前指向当前
        pre = cur;
        // 当前指向后继
        cur = t;
    }
    return pre;
}


//另一种方法
 public ListNode swapPairs(ListNode head) {
        ListNode denny=new ListNode(-1,head);
        ListNode first=null;
        ListNode cur=denny;
        ListNode temp=null;
        ListNode second=null;
        while(cur.next!=null&&cur.next.next!=null){
            //保存下一组的起始位置
           temp=cur.next.next.next；
           first=cur.next;
           second= cur.next.next;
            //虚拟头先指向第二个节点
           cur.next=second;
            //第二个在指向第一个节点
           second.next=first;
            //第一个在指向第三个节点
           first.next=temp;
            //cur在移动到下一组的起始位置
           cur=cur.next.next;
           }
    return denny.next;
    }
```

## 【82】、删除排序链表的重复元素II

```java
/*
	o(n)
	o(1)
	因为有序，所以重复的元素在链表中出现的位置是连续的
*/
public ListNode deleteDuplicates(ListNode head) {
    if (head == null) {
        return head;
    }
    // 由于链表的头节点可能会被删除，因此我们需要额外使用一个哑节点（dummy node）指向链表的头节点。
    ListNode dummy = new ListNode(0, head);

    ListNode cur = dummy;
    while (cur.next != null && cur.next.next != null) {
        if (cur.next.val == cur.next.next.val) {
            // 此时需要把cur.next及之后所有相同元素值li
            int x = cur.next.val;
            while (cur.next != null && cur.next.val == x) {
                cur.next = cur.next.next;
            }
        } else {
            cur = cur.next;
        }
    }

    return dummy.next;
}
```

## 【92】、反转链表II

### 解法1

普通做法，记录left的前一个和right的后一个，再用传统反转链表，最后拼接

```java
/*
	o(n)
	o(1)
*/
public ListNode reverseBetween(ListNode head, int left, int right) {
    // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
    ListNode dummyNode = new ListNode(-1);
    dummyNode.next = head;

    ListNode pre = dummyNode;
    // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
    // 建议写在 for 循环里，语义清晰
    for (int i = 0; i < left - 1; i++) {
        pre = pre.next;
    }

    // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
    ListNode rightNode = pre;
    for (int i = 0; i < right - left + 1; i++) {
        rightNode = rightNode.next;
    }

    // 第 3 步：切断出一个子链表（截取链表）
    ListNode leftNode = pre.next;
    ListNode curr = rightNode.next;

    // 注意：切断链接
    pre.next = null;
    rightNode.next = null;

    // 第 4 步：同第 206 题，反转链表的子区间
    reverseLinkedList(leftNode);

    // 第 5 步：接回到原来的链表中
    pre.next = rightNode;
    leftNode.next = curr;
    return dummyNode.next;
}
private void reverseLinkedList(ListNode head) {
    // 也可以使用递归反转一个链表
    ListNode pre = null;
    ListNode cur = head;

    while (cur != null) {
        ListNode next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
}
```

### 解法2

头插法，为了解决遍历链表两次的问题，使用1次遍历

思想：在到需要反转的区间里，每遍历到一个节点，就让这个新节点放到反转部分的起始位置

```java
/*
	看不懂的话自己画一下
	o(n)
	o(1)
*/
public ListNode reverseBetween(ListNode head, int left, int right) {
    
    ListNode dummyNode = new ListNode(-1);
    dummyNode.next = head;
    // pre：永远指向待反转区域的第一个节点 left 的前一个节点，在循环过程中不变。
    ListNode pre = dummyNode;
    for (int i = 0; i < left - 1; i++) {
        pre = pre.next;
    }
    // cur：指向待反转区域的第一个节点 left；
    ListNode cur = pre.next;
    // next：永远指向 curr 的下一个节点，循环过程中，curr 变化以后 next 会变化；
    ListNode next;
    for (int i = 0; i < right - left; i++) {
        next = cur.next;
        cur.next = next.next;
        next.next = pre.next;
        pre.next = next;
    }
    return dummyNode.next;
}
```



## 【138】、随机链表的复制

```java
/*
    o(n)    遍历链表3次
    o(1)
 */
public Node copyRandomList(Node head) {
    if (head == null) {
        return null;
    }
    // 把复制体放到本体之后
    for (Node node = head; node != null; node = node.next.next) {
        Node nodeNew = new Node(node.val);
        // 把新的当前node的复制体放到node和node下一个的中间
        nodeNew.next = node.next;
        node.next = nodeNew;
    }
    // 设置复制体的随机值
    for (Node node = head; node != null; node = node.next.next) {
        Node nodeNew = node.next;
        // node.random.next是node.random的复制体
        nodeNew.random = (node.random != null) ? node.random.next : null;
    }
    // 连接所有复制体
    Node headNew = head.next;
    for (Node node = head; node != null; node = node.next) {
        // nodeNew是复制体
        Node nodeNew = node.next;
        // 非复制体的下一个是下一个非复制体
        node.next = node.next.next;
        // 复制体的下一个是
        nodeNew.next = (nodeNew.next != null) ? nodeNew.next.next : null;
    }
    return headNew;
}
```

## 【141】、环形链表

```java
/*
    o(n)    链表不存在环时，快指针会先为null，每个节点最多被访问两次，
            存在环时，每一轮移动，两个指针距离-1，初始距离是环长度，最多移动n轮
    o(1)    两个指针
 */
public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) {
        return false;
    }
    ListNode slow = head;
    ListNode fast = head.next;
    while (slow != fast) {
        if (fast == null || fast.next == null) {
            return false;
        }
        slow = slow.next;
        fast = fast.next.next;
    }
    return true;
}
```

## 【142】、环形链表II

```java
/*
	a：头部到入口结点个数，b：链表环结点个数
    第一次相遇的时候，fast走的步数是slow的2倍，f = 2s，fast比slow多走了n个环的长度，f = s + nb
    得出 f = 2nb，s = nb
    此时fast指针从头开始
    第二次相遇，两指针每次走1步，让fast指向头，此时 f = 0, s = nb，然后f = a时，s = a + nb，两指针相遇
    o(n)
    o(1)
*/
public ListNode detectCycle(ListNode head) {
    if (head == null || head.next == null) {
        return null;
    }
    ListNode slow = head;
    ListNode fast = head.next;
    while (slow != fast) {
        if (fast == null || fast.next == null) {
            return null;
        }
        slow = slow.next;
        fast = fast.next.next;
    }
    fast = head;
    // 启动位置不一致，调整一致
    slow = slow.next;
    while (slow != fast) {
        slow = slow.next;
        fast = fast.next;
    }
    return fast;
}
```

## 【143】、重排链表

```java
/*
    1->2->3->4->5
    先找到中间节点3，再把右边部分翻转1->2->3<-4<-5
    之后head1->1。head2->5。每次让head->head2，再让head2->head->next。之后把head和head2向里收缩
    o(n)
    o(1)
*/
public void reorderList(ListNode head) {
    // 获取中间节点
    ListNode mid = middle(head);
    // 从中间开始翻转右边
    ListNode head2 = reverse(mid);
    while (head2.next != null) {
        ListNode next = head.next;
        ListNode next2 = head2.next;
        // 先让head指向head2
        head.next = head2;
        // 再让head2指向head的next
        head2.next = next;
        // head和head2向里收缩
        head = next;
        head2 = next2;
    }
}
// 翻转链表
private ListNode reverse(ListNode head) {
    ListNode pre = null;
    ListNode cur = head;
    while (cur != null) {
        ListNode next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
// 获取中间节点，快慢指针
private ListNode middle(ListNode head) {
    ListNode fast = head;
    ListNode slow = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
    }
    return slow;
}
```

## 【148】、排序链表

```java
/*
    递归归并排序
    o(nlogn)    n是链表长度
    o(logn)     递归调用栈深度
 */
public ListNode sortList(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode fast = head.next;
    // 奇数   走向中间节点
    // 偶数   走向中间的左边节点
    ListNode slow = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    // 中间的右边的头节点
    ListNode tmp = slow.next;
    // slow是前一段的最后一个节点，截断
    slow.next = null;
    // 排序左右两边
    ListNode left = sortList(head);
    ListNode right = sortList(tmp);
    ListNode h = new ListNode();
    ListNode res = h;

    // 开始合并
    while (left != null && right != null) {
        if (left.val < right.val) {
            h.next = left;
            left = left.next;
        } else {
            h.next = right;
            right = right.next;
        }
        h = h.next;
    }
    // 一边为空就将另一边加入
    h.next = left != null ? left : right;
    return res.next;
}
```

## 【160】、相交链表

```java
/*
    如果有相交，在他们相交时，p走的长度和q一样
    如果没有相交，都会走到null然后退出循环
    A+B=B+A
    o(m + n)    m和n分别为两个链表的长度，每个指针遍历两个链表各一次
    o(1)
 */
//双指针分别遍历，末尾交换
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {

    ListNode p = headA;
    ListNode q = headB;
    while (p != q) {
        p = p == null ? headB : p.next;
        q = q == null ? headA : q.next;
    }
    return p;
}//用双指针分别遍历两链表，到末尾时交换路径，确保总路径相同，相遇点即为交点，否则返回 null。
```

## 【203】、移除链表元素

```java
/*
        设置虚拟头节点
        o(n)
        o(1)
     */
public ListNode removeElements(ListNode head, int val) {

    ListNode h = new ListNode();
    h.next = head;
    ListNode p = h;
    while (p.next != null) {
        if (p.next.val == val) {
            p.next = p.next.next;
        } else {
            p = p.next;
        }
    }
    return h.next;
}
```

## 【206】、反转链表、链表翻转

```java
/*
	迭代法，使用 pre 和 cur 双指针，每次将 cur.next 指向 pre，然后 pre 和 cur 同步前移，直到 cur 为 null，此时 pre 就是新链表的头节点。
    o(n)
    o(1)
 */
public ListNode reverseList(ListNode head) {
    ListNode cur = head;
    ListNode pre = null;
    while (cur != null) {
        // 要将当前节点的下一个指向之前节点，就先保存后继节点
        ListNode temp = cur.next;
        cur.next = pre;
        pre = cur;
        // 下一次，当前就是现在的下一个节点
        cur = temp;
    }
    // cur == null，上一个就是第一个
    return pre;
}
```

## 【234】、回文链表

```java
/*
    反转后半部分进行对比
    o(n)
    o(1)    修改指向
 */
public boolean isPalindrome(ListNode head) {
    if (head == null || head.next == null) {
        return true;
    }
    // A的终点
    ListNode endA = getMid(head);
    // B的起点
    ListNode startB = endA.next;
    endA.next = null;
    // 反转B
    startB = reverse(startB);

    // 对比
    boolean res = compare(head, startB);
    // 还原
    endA.next = reverse(startB);
    return res;
}

// 快慢指针找中点
ListNode getMid(ListNode head) {
    ListNode p = head;
    ListNode q = head;
    while (q.next != null && q.next.next != null) {
        p = p.next;
        q = q.next.next;
    }
    return p;
}

// 链表反转
ListNode reverse(ListNode head) {
    ListNode pre = null;
    ListNode cur = head;
    while (cur != null) {
        ListNode t = cur.next;
        cur.next = pre;
        pre = cur;
        cur = t;
    }
    return pre;
}

// 链表对比，len(b) <= len(a)
boolean compare(ListNode A, ListNode B) {
    while (B != null) {
        if (A.val != B.val) {
            return false;
        }
        A = A.next;
        B = B.next;
    }
    return true;
}
```

## 【328】、奇偶链表

```java
/*
	一次遍历，把奇偶链表分开，再连接
	o(n)
	o(1)
*/
public ListNode oddEvenList(ListNode head) {
    if (head == null) return head;
    ListNode h = new ListNode();
    h.next = head;
    ListNode A = new ListNode();
    ListNode B = new ListNode();
    ListNode tailA = A;
    ListNode tailB = B;
    ListNode tail = h;
    boolean isOu = false;
    // tail.next是yao
    while (tail.next != null) {
        ListNode next = tail.next.next;
        if (isOu) {
            tailB.next = tail.next;
            tailB = tailB.next;
            tailB.next = null;
        } else {
            tailA.next = tail.next;
            tailA = tailA.next;
            tailA.next = null;
        }
        tail.next = next;
        isOu = !isOu;
    }
    tailA.next = B.next;
    return A.next;
}
```



## 【876】、链表的中间结点

```java
/*
    快慢指针
    o(n)
    o(1)
*/
public ListNode middleNode(ListNode head) {
    ListNode fast = head;
    ListNode slow = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
    }
    return slow;
}
```





# 二叉树

## 【94】、二叉树的中序遍历

```java
/*
    中序遍历    左中右
    递归和迭代的时间复杂度和空间复杂度都是o(n)
    入栈顺序    左 右
 */
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    if (root == null) {
        return res;
    }
    LinkedList<TreeNode> stack = new LinkedList<>();
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        if (cur != null) { //当前不空，还可以往左子树继续遍历
            stack.push(cur);
            cur = cur.left;
        } else {
            // 当前节点为空，说明当前节点和左子树已经遍历完毕，需要访问当前节点，
            // 此时弹出栈顶（栈顶是当前节点的父节点或更高层的祖先节点），将该节点的值添加到结果中，
            // 将当前节点指向当前节点的右节点
            cur = stack.pop();
            res.add(cur.val);
            cur = cur.right;
        }
    }
    return res;
}
```

## 【98】、验证二叉搜索树

```java
/*
    每次判断node的值在不在[lower, upper]之间，不在就直接返回false
    o(n)    每个节点最多访问一次
    o(n)    递归深度，最深是树的高度
 */
public boolean isValidBST(TreeNode root) {
    return vaild(root, Long.MIN_VALUE, Long.MAX_VALUE);
}
public boolean vaild(TreeNode node, long lower, long upper) {
    if (node == null) {
        return true;
    }
    // 比左边小或者比右边大
    if (node.val <= lower || node.val >= upper) {
        return false;
    }
    // 左边比当前小同时右边比当前大
    return vaild(node.left, lower, node.val) && vaild(node.right, node.val, upper);
}
```

## 【101】、对称二叉树

```java
/*
    o(n)    遍历，每个节点都要访问一次
    o(n)    链表的高度可以达到n
 */
public boolean isSymmetric(TreeNode root) {

    return duiCheng(root.left, root.right);
}

private boolean duiCheng(TreeNode left, TreeNode right) {
    if (left == null && right == null) {
        return true;
    }
    if (left == null || right == null) {
        return false;
    }
    if (left.val != right.val) {
        return false;
    }
    return duiCheng(left.left, right.right) && duiCheng(left.right, right.left);
}
```

## 【102】、二叉树的层序遍历

```java
/*
    o(n)    每个节点进出队列一次
    o(n)    队列元素不超过n个
 */
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null) return res;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        List<Integer> path = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();
            path.add(node.val);
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
        res.add(path);
    }
    return res;
}
```

## 【103】、二叉树的锯齿形层序遍历

```java
/*
    bfs，根节点第0层，偶数层从左往右，奇数层从右往左
    o(n)
    o(n)
*/
public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null)
        return res;
    //创建队列，保存节点
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);//先把节点加入到队列中
    boolean leftToRight = true;//第一步先从左边开始打印
    while (!queue.isEmpty()) {
        //记录每层节点的值
        List<Integer> level = new ArrayList<>();
        //统计这一层有多少个节点
        int count = queue.size();
        //遍历这一层的所有节点，把他们全部从队列中移出来，顺便
        //把他们的值加入到集合level中，接着再把他们的子节点（如果有）
        //加入到队列中
        for (int i = 0; i < count; i++) {
            //poll移除队列头部元素（队列在头部移除，尾部添加）
            TreeNode node = queue.poll();
            //判断是从左往右打印还是从右往左打印。
            if (leftToRight) {
                //如果从左边打印，直接把访问的节点值加入到列表level的末尾即可
                level.add(node.val);
            } else {
                //如果是从右边开始打印，每次要把访问的节点值
                //加入到列表的最前面
                level.add(0, node.val);
            }
            //左右子节点如果不为空会被加入到队列中
            if (node.left != null)
                queue.add(node.left);
            if (node.right != null)
                queue.add(node.right);
        }
        //把这一层的节点值加入到集合res中
        res.add(level);
        //改变下次访问的方向
        leftToRight = !leftToRight;
    }
    return res;
}
```

## 【104】、二叉树的最大深度

```java
/*
    o(n)    每个节点在递归只遍历一次
    o(height)   栈空间取决于递归的深度
 */
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int left = maxDepth(root.left);
    int right = maxDepth(root.right);
    return Math.max(left, right) + 1;
}
```

## 【105】、从前序与中序遍历序列构造二叉树；LCR124、推理二叉树

```java
/*
    前：中左右
    中：左中右
    o(n)    递归建立n个节点，每层节点建立搜索o(1)
    o(n)    map，递归深度最差达到n
 */
int[] preorder;
Map<Integer, Integer> map = new HashMap<>();
public TreeNode buildTree(int[] preorder, int[] inorder) {
    this.preorder = preorder;
    for (int i = 0; i < inorder.length; i++) {
        map.put(inorder[i], i);
    }
    return recur(0, 0, inorder.length - 1);
}

private TreeNode recur(int root, int left, int right) {
    // 递归终止
    if (left > right) return null;
    // 建立根节点（先序的根）
    TreeNode node = new TreeNode(preorder[root]);
    // 获取根节点在中序的下标，划分根节点、左子树、右子树
    int i = map.get(preorder[root]);
    // 根节点的左子树是以左子树的根(root + 1)，left不变，right变为左子树最后一个
    node.left = recur(root + 1, left, i - 1);
    // 根节点的右子树是以右子树的根(root + i - left + 1)，i - left是左子树的长度，+1是右子树的根
    // 左边变为右子树的左边
    node.right = recur(root + i - left + 1, i + 1, right);
    return node;
}
```

## 【108】、将有序数组转换为二叉搜索树

```java
/*
    中序遍历，总是选择中间位置的左边数字作为根节点
    o(n)    每个数字只访问一次
    o(logn) 递归栈深度
 */
public TreeNode sortedArrayToBST(int[] nums) {
    return build(nums, 0, nums.length - 1);
}

private TreeNode build(int[] nums, int left, int right) {
    if (left > right) return null;
    // 总是选择中间节点的左边数字作为根节点
    int mid = left + (right - left) / 2;
    TreeNode root = new TreeNode(nums[mid]);
    root.left = build(nums, left, mid - 1);
    root.right = build(nums, mid + 1, right);
    return root;
}
```

## 【114】、二叉树展开为链表

```java
/*
	举例子看，左右都变为链表后，中间root怎么处理
    先将根节点的左子树变为链表
    再将根节点的右子树变为链表
    设置根节点的右子树是变成链表的左子树的根
    最后将变成链表的右子树放在变成链表的左子树的最右边
    o(n)    最坏情况下，如果已经是链表，while不会执行，每个节点被访问一次
    o(n)    单链表时，深度是树高度
 */
public void flatten(TreeNode root) {
    if (root == null) {
        return;
    }
    // 将根节点左子树变为链表
    flatten(root.left);
    // 将根节点右子树变为链表
    flatten(root.right);
    TreeNode temp = root.right;
    // 先把树的右边换成左边的链表
    root.right = root.left;
    // 将左边置空
    root.left = null;
    // 找到树的最右边的节点
    while (root.right != null) root = root.right;
    // 把右边链表接到刚才树的最右边节点
    root.right = temp;
}
```

## 【124】、二叉树中的最大路径和

```java
/*
    o(n)    每个节点访问不超过2次
    o(n)    递归最大二叉树高度，最坏是节点个数
 */
int ans = Integer.MIN_VALUE;
public int maxPathSum(TreeNode root) {
    dfs(root);
    return ans;
}

private int dfs(TreeNode root) {
    if (root == null) return 0;
    // 递归计算左右子节点最大贡献值
    // 贡献大于0才选
    int left = Math.max(dfs(root.left), 0);
    int right = Math.max(dfs(root.right), 0);
    // 该节点最大路径和取决于该节点的值和左右子节点最大贡献和
    int res = root.val + left + right;
    // 更新答案
    ans = Math.max(ans, res);
    // 返回节点最大贡献值
    return root.val + Math.max(left, right);
}
```

## 【129】、求根到叶子节点数字之和

```java
/*
	dfs
	o(n)	二叉树节点个数
	o(n)	递归栈深度
*/
public int sumNumbers(TreeNode root) {
    return dfs(root, 0);
}

public int dfs(TreeNode root, int prevSum) {
    if (root == null) {
        return 0;
    }
    int sum = prevSum * 10 + root.val;
    if (root.left == null && root.right == null) {
        return sum;
    } else {
        return dfs(root.left, sum) + dfs(root.right, sum);
    }
}
```

## 【LCR152】、验证二叉搜索树的后续遍历序列

```java
/*
        后序：左右中。倒序中右左，是先序遍历中左右的镜像
        往右子树遍历时，value越来越大，一旦出现value变小，就说明要开始进入左子树
        只要栈顶元素还比当前节点大，就表示还是右子树，要移除，因为要找左孩子节点直接相连接的父节点，就是根。要一直弹出，直到栈顶元素小于节点，
        或者栈为空，栈顶的上一个元素就是子树的根。之后继续向前遍历，之后左子树的每个节点都要比子树根小才满足
        o(n)    每个节点入栈出栈一次
        o(n)
*/
public boolean verifyTreeOrder(int[] postorder) {
    // 存储值递增的节点
    Deque<Integer> stack = new LinkedList<>();
    // 上一个根节点元素
    int root = Integer.MAX_VALUE;
    // 逆向遍历，翻转先序，中右左
    for(int i = postorder.length - 1; i >= 0; i--) {
        // 左子树元素必须小于peek的根，否则不满足二叉搜索树
        if(postorder[i] > root) return false;
        while (!stack.isEmpty() && stack.peek() > postorder[i]) {
            // 数组元素小于单调栈的元素了，表示往左子树走了，记录上个根节点
            // 找到这个左子树对用的根节点，之前右子树弹出
            root = stack.pop();
        }
        // 新元素入栈
        stack.add(postorder[i]);
    }
    return true;
}
```

## 【199】、二叉树的右视图、LCR046

```java
/*
    可以层序遍历，每次把这一层的最后一个加入结果
    也可以递归，先递归右子树，再递归左子树，只有当深度==结果数时才加入结果
    比如，前几层都是右子树的右边，但更下面的层是一个节点的左子树，当递归到其他节点时发现深度<结果数，就继续先右后左
    最后发现左边有一个符合条件的，再加入结果，先1,3,4，最后加7
     1
    / \
   2   3
  / \    \
 6   5    4
    /    
   7
    o(n)    二叉树节点个数
    o(n)    递归栈深度，链表
 */
List<Integer> res = new ArrayList<>();
public List<Integer> rightSideView(TreeNode root) {
    dfs(root, 0);
    return res;
}

private void dfs(TreeNode root, int depth) {
    if (root == null) return;
    if (depth == res.size()) {
        res.add(root.val);
    }
    // 先递归右子树，再递归左子树
    dfs(root.right, depth + 1);
    dfs(root.left, depth + 1);
}
```

## 【226】、翻转二叉树

```java
/*
    o(n)    遍历树所有节点
    o(n)    退化成链表
 */
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }
    // 把左边翻转
    TreeNode newLeft = invertTree(root.left);
    // 把右边翻转
    TreeNode newRight = invertTree(root.right);
    // 设置root的左右节点
    root.left = newRight;
    root.right = newLeft;
    return root;
}
```

## 【230】、二叉搜索树中第k小的元素

```java
/*
    二叉搜索树中序遍历是递增的
    也就是求中序遍历的第k个节点
    o(n)    链表时，全部都可能被访问
    o(n)    链表，递归深度
 */
int res;
int k;
public int kthSmallest(TreeNode root, int k) {
    this.k = k;
    dfs(root);
    return res;
}

private void dfs(TreeNode root) {
    if (root == null) return;
    dfs(root.left);
    // 到了第k个节点
    if (--k == 0) {
        res = root.val;
    } else {
        dfs(root.right);
    }
}
```

## 【235】、二叉搜索树的最近公共祖先

```java
/*
    一次遍历，每次判断对应值之间的关系
    o(n)
    o(1)
*/
public TreeNode lowestCommonres(TreeNode root, TreeNode p, TreeNode q) {
    TreeNode res = root;
    while (true) {
        if (p.val < res.val && q.val < res.val) {
            // 当前节点值比p和q都大，说明p和q都在当前节点左子树
            res = res.left;
        } else if (p.val > res.val && q.val > res.val) {
            // 当前节点值比p和q都小，说明p和q都在当前节点右子树
            res = res.right;
        } else {
            // 分岔点，此时p和q要么在当前节点的不同子树中，要么其中一个就是当前节点
            break;
        }
    }
    return res;
}
```

## 【236】、二叉树的最近公共祖先

```java
/*
    root是pq最近公共祖先
    1. p、q在root子树中，分布在两侧
    2. p = root，q在root的子树中
    3. q = root，p在root的子树中
    前序遍历，中左右，遇到p/q时返回，从底至顶回溯，pq在异侧时返回root
    因为如果根节点是p/q就直接返回，说明是先判断，就是前序而不是后序
    o(n)    最差情况遍历所有节点
    o(n)    最差递归深度n
 */
// 在root下，返回pq的最近公共祖先
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q) return root;
    // 在左右子树找pq最近公共祖先
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    // 1. left和right都空时，说明root的左右子树都不包含pq，返回null
    // 2. left和right都不为空时，说明p，q在root的异侧，所以返回root
    // 3. 有一个不为空时，返回不为空的，因为是先找到不为空的
    if (left == null) return right;
    if (right == null) return left;
    return root;
}
```

## 【331】、验证二叉树的前序序列化

```java
/*
     "9,3,4,#,#,1,#,#,2,#,6,#,#"
    槽位数量变化：1，2，3，4，2，3，2，1，2，1，2，1，0
    #就减1个槽，数字就加1个槽，比如先是9，此时有2个槽，下1个3会占用1个槽，同时添加2个槽，如果是#就会减1个槽
    o(n)
    o(1)
*/
public boolean isValidSerialization(String preorder) {
    int n = preorder.length();
    int i = 0;
    // 剩余槽的数量
    int slots = 1;
    while (i < n) {
        if (slots == 0) {
            return false;
        }
        if (preorder.charAt(i) == ',') {
            i++;
        } else if (preorder.charAt(i) == '#'){
            // #，槽位数量-1
            slots--;
            i++;
        } else {
            // 读一个数字
            while (i < n && preorder.charAt(i) != ',') {
                i++;
            }
            slots++; // slots = slots - 1 + 2
        }
    }
    return slots == 0;
}
```

## 【437】、路径总和III

```java
/*
  o(n)    每个节点只遍历一次
  o(n)    map
                       1
                    / 
                   2    
                  / 
                 3   
                / 
               4  
               节点1的前缀和为: 1
节点3的前缀和为: 1 + 2 + 3 = 6

prefix(3) - prefix(1) == 5
所以 节点1 到 节点3 之间有一条符合要求的路径( 2 --> 3 )
prefix(3) - 5 = prefix(1) 对应 cur - target

*/
// key是前缀和，value是大小为key的前缀和出现的次数
Map<Long, Integer> map = new HashMap<>();
public int pathSum(TreeNode root, int targetSum) {
    // 为了考虑从根节点开始的合法路径
    map.put(0l, 1);
    return recur(root, targetSum, 0l);
}

private int recur(TreeNode root, int target, long cur) {

    if (root == null) return 0;
    int res = 0;
    // 当前路径的和
    cur += root.val;
    // cur - target相当于找路径起点，当前点到起点的距离就是target，（不包括起点，包括当前点）
    res += map.getOrDefault(cur - target, 0);
    // 更新路径上当前节点前缀和的个数
    map.put(cur, map.getOrDefault(cur, 0) + 1);
    // 进入下一层
    res += recur(root.left, target, cur);
    res += recur(root.right, target, cur);

    // 回到本层，恢复状态，去除当前节点的前缀和数量
    map.put(cur, map.get(cur) - 1);
    return res;
}
```

## 【543】、二叉树的直径

```java
/*
    可能不经过root节点
    某个节点为起点，左子和右子向下遍历的路径拼接
    o(n)    每个节点被访问一次
    o(height)   递归深度
 */
int ans = 0;
public int diameterOfBinaryTree(TreeNode root) {
    depth(root);
    return ans;
}
// 返回以root为根节点的深度
private int depth(TreeNode root) {
    if (root == null) return 0;
    int left = depth(root.left);
    int right = depth(root.right);
    // 此时可能以该root为根节点存在最长直径
    ans = Math.max(ans, left + right);
    // 返回以root为根节点的深度
    return Math.max(left, right) + 1;
}
```







# 多线程

## 两个线程交替打印1-100

```java
private static final Object lock = new Object();

private static volatile int num = 1;

private static volatile boolean flag = true;

public static void main(String[] args) throws InterruptedException {
    Thread t1 = new Thread(() -> {

        while (num <= 100) {
            if (flag) {

                synchronized (lock) {
                    lock.notify();
                    System.out.println(Thread.currentThread().getName() + ":" + num);
                    ++num;
                    try {
                        flag = false;
                        lock.wait(10);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }

                }
            }
        }
    });

    Thread t2 = new Thread(() -> {
        while (num <= 100) {
            if (!flag) {
                synchronized (lock) {
                    lock.notify();
                    System.out.println(Thread.currentThread().getName() + ":" + num);
                    ++num;
                    try {
                        flag = true;
                        lock.wait(10);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    });

    t1.start();
    t2.start();
    t1.join();
    t2.join();

}
```







# 其他！！！

## 堆排序

```java
// da'ding
public static void heapSort(int[] arr) {
    int temp = 0;
    //将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆
    for (int i = arr.length / 2 - 1; i >= 0; i--) {
        adjustHeap(arr,i,arr.length);
    }
    //将堆顶元素与末尾元素交换。将最大的元素沉到数组末端
    for (int j = arr.length-1; j > 0; j--) {
        temp = arr[j];
        arr[j] = arr[0];
        arr[0] = temp;
        //重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序
        adjustHeap(arr,0,j);
    }
}

/** 将一个数组（二叉树）调整成一个大顶堆
     * 功能：完成将以i对应的非叶子节点的树调整成大顶堆
     * @param arr 待调整的数组
     * @param i 表示非叶子节点在数组中的索引
     * @param length 表示对多少个元素继续调整，length是在逐渐的减少
     */
public static void adjustHeap(int[] arr,int i, int length) {
    int temp = arr[i]; //取出当前元素的值保存在临时变量
    //k = 2 * i + 1是i节点的左子节点
    for (int k = 2 * i + 1; k < length; k = 2 * k + 1) {
        if(k + 1 < length && arr[k] < arr[k + 1]) { //说明左子节点的值小于右子节点的值
            k++; //k指向右子节点
        }
        if(arr[k] > temp) { //如果子节点大于父节点
            arr[i] = arr[k]; //把较大的值赋给当前节点
            i = k; //i指向k继续比较
        } else {
            break;
        }
    }
    //当for循环结束后，我们已经将以i为父节点的树的最大值，放在了最顶（局部）
    arr[i] = temp; //将temp的值放到调整后的位置
}
```



## 最大奇约数之和

奇数的最大奇约数是本身，偶数的最大奇约数是一直除2得到的第一个j

## 快速排序

**核心思想**：选取一个基准元素，将数组分成两个子数组，小于基准元素的和大于基准元素的，然后递归地对这两个子数组进行排序

```java
public class Test {

    public static void main(String[] args) {
        int[] arr = new int[]{5,7,3,3,6,4};
        System.out.println("原始数组："+ Arrays.toString(arr));
        quickSort(arr,0,arr.length - 1);
        System.out.println("排序后的数组："+ Arrays.toString(arr));
    }

    public static void quickSort(int[] arr,int left,int right) {

        //递归结束条件left < right
        if(left < right){
            // 通过分区函数得到基准元素的索引
            int pivotIndex = partition(arr, left, right);
            //递归对基准元素左边的子数组进行快速排序
            quickSort(arr,left,pivotIndex-1);
            //递归对基准元素右边的子数组进行快速排序
            quickSort(arr,pivotIndex+1,right);
        }
    }

    public static int partition(int[] arr,int left,int right) {
        // 选择最后一个元素作为基准元素
        int pivot = arr[right];
        int i = left;

        //循环数组，如果满足条件，则将满足条件的元素交换到arr[i]，同时i++,循环完成之后i之前的元素则全部为小于基准元素的元素
        for (int j = left; j < right; j++) {
            if(arr[j] < pivot){
                if(j != i){
                   int temp  = arr[i];
                   arr[i] = arr[j];
                   arr[j] = temp;
                }
                i++;
            }
        }

        // 交换 arr[i] 和基准元素
        int temp = arr[i];
        arr[i] = arr[right];
        arr[right] = temp;

        //返回基准元素的下标
        return i;
    }

}
```



## 大数相乘（p43）

## 中序遍历树（p94）

## 二叉树最大路径的长度

```java
private static int max;

static class Node {
    int val;
    Node left;
    Node right;

    public Node(int val) { this.val = val; }

    public Node(int val, Node left, Node right) {
        this.left = left;
        this.right = right;
    }
}

public static void main(String[] args) {
    /* 定义树结构 */
    Node head = new Node(1);
    head.left = new Node(2, new Node(4, new Node(41, new Node(51), new Node(52)), null), new Node(5, new Node(42, null, new Node(53)), null));
    head.right = new Node(3);
    /* 调用方法 */
    max = 0;
    int result = getMaxLength(head);
    System.out.println(max);
}

private static int getMaxLength(Node root) {
    if (root == null) {
        return 0;
    }
    int left = 0, right = 0;
    if (root.left != null) {
        left = getMaxLength(root.left);
    }
    if (root.right != null) {
        right = getMaxLength(root.right);
    }
    max = Math.max(left + right + 1, max);
    return Math.max(left, right) + 1;
}
```

# 美团3.16笔试

## q3

小美拿到了一个数组，她每次操作会将除了第x个元素的其余元素翻倍，一共操作了q次。请你帮小美计算操作结束后所有元素之和。 由于答案过大，请对10^9+7取模。

思路：统计每个元素最后翻倍的次数就行，快速求a^b可以使用快速幂

```java
import java.util.*;
import java.math.*;

public class Main {
    static final int mod = (int) Math.pow(10, 9) + 7;

    // 快速幂
    // 比如3^3
    // res = 1，t = 3，b = 3
    // res = (res * t) = 3，b = 1，t = 9
    // res = (res * t) = 27，b = 0，t = 81
    /
    static long qpow(int a, int b) {
        // t是当前底数
        long res = 1, t = a;
        // 指数>0就一直循环
        while (b > 0) {
            // 判断指数最低位是否为1，是就更新res为res*当前底数
            if ((b & 1) == 1) {
                res = (res * t) % mod;
            }
            // 指数右移一位，相当于/2
            b >>= 1;
            // 更新底数
            t = (t * t) % mod;
        }
        return res;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int q = scanner.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = scanner.nextInt();
        }
        // s[i]表示i被处理过多少次，因为xi<=n，所以都在数组范围内
        int[] s = new int[n + 1];
        // 首先考虑每个元素都被处理过q次
        Arrays.fill(s, q);
        for (int i = 0; i < q; i++) {
            int x = scanner.nextInt();
            // 出现一次就给它出现次数-1
            s[x] -= 1;
        }
        long res = 0;
        for (int i = 0; i < n; i++) {
            // res每次加a[i]的翻倍次数，等于乘2^a[i]出现次数
            res = (res + qpow(2, s[i + 1]) * a[i] % mod) % mod;
        }
        System.out.println(res);
    }
}


class Solution {
    public String longestCommonPrefix(String[] strs) {
        //如果输入的strs为空，则返回空字符串""
        if(strs.length==0){
            return "";
        }
        //定义一个ans为strs.[0],获取到strs的第一个字符串为了一下面的循环比较
        String  ans = strs[0];
        for(int i=0; i<strs.length; i++){
            //在这里定义j=0，而不是在for里面定义；是为了ans.substring(0,j)能调用j的值
            int j = 0;
            for(;j<ans.length() && j<strs[i].length(); j++){
                //比较俩个字符串相同的部分，不相同则退出循环
                if(ans.charAt(j) != strs[i].charAt(j))
                    break;
            }
            //获取从0到j相同的字符串
            ans = ans.substring(0,j);
            //如果ans获取的结果为空则返回空字符
            if(ans.equals(" "))
                return ans;      
        }
        //返回最终获取到的ans
        return ans;
        
    }
}

class Solution {
    public String longestCommonPrefix(String[] strs) {
        if(strs.length == 0) 
            return "";
        String ans = strs[0];
        for(int i =1;i<strs.length;i++) {
            int j=0;
            for(;j<ans.length() && j < strs[i].length();j++) {
                if(ans.charAt(j) != strs[i].charAt(j))
                    break;
            }
            ans = ans.substring(0, j);
            if(ans.equals(""))
                return ans;
        }
        return ans;
    }
}


```



# 字节

## 奇数位升序，偶数位降序，链表排序

>题目描述：一个链表，奇数位升序偶数位降序，让链表变成升序的。
>
>比如：1 8 3 6 5 4 7 2 9，最后输出1 2 3 4 5 6 7 8 9。

1. 首先根据奇数位和偶数位拆分成两个链表。
2. 然后对偶数链表进行反转。
3. 最后将两个有序链表进行合并

```java
public class OddIncreaseEvenDecrease {
    /**
     * 按照奇偶位拆分成两个链表
     * @param head
     * @return
     */
    public static Node[] getLists(Node head){
        Node head1 = null;
        Node head2 = null;
        
        Node cur1 = null;
        Node cur2 = null;
        int count = 1;//用来计数
        while(head != null){
            if(count % 2 == 1){
                if(cur1 != null){
                    cur1.next = head;
                    cur1 = cur1.next;
                }else{
                    cur1 = head;
                    head1 = cur1;
                }
            }else{
                if(cur2 != null){
                    cur2.next = head;
                    cur2 = cur2.next;
                }else{
                    cur2 = head;
                    head2 = cur2;
                }
            }
            head = head.next;
            count++;
        }
        //跳出循环，要让最后两个末尾元素的下一个都指向null
        cur1.next = null;
        cur2.next = null;
        
        Node[] nodes = new Node[]{head1, head2};
        return nodes;
    }
    
    /**
     * 反转链表
     * @param head
     * @return
     */
    public static Node reverseList(Node head){
        Node pre = null;
        Node next = null;
        while(head != null){
            next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }
    
    /**
     * 合并两个有序链表
     * @param head1
     * @param head2
     * @return
     */
    public static Node CombineList(Node head1, Node head2){
        if(head1 == null || head2 == null){
            return head1 != null ? head1 : head2;
        }
        Node head = head1.value < head2.value ? head1 : head2;
        Node cur1 = head == head1 ? head1 : head2;
        Node cur2 = head == head1 ? head2 : head1;
        Node pre = null;
        Node next = null;
        while(cur1 != null && cur2 != null){
            if(cur1.value <= cur2.value){//这里一定要有=，否则一旦cur1的value和cur2的value相等的话，下面的pre.next会出现空指针异常
                pre = cur1;
                cur1 = cur1.next;
            }else{
                next = cur2.next;
                pre.next = cur2;
                cur2.next = cur1;
                pre = cur2;
                cur2 = next;
            }
        }
        pre.next = cur1 == null ? cur2 : cur1;
        
        return head;
    }
  
}
```

## 分数化小数

写一个程序，输入一个形如N/D的分数(N是分子，D是分母)，输出它的小数形式。

如果小数有循环节的话，把循环节放在一对圆括号中。

例如， 1/3 = .33333333　写成0.(3)

41/333 = 0.123123123…　写成0.(123)

```java
// 记录循环节出现次数，出现第三次时确定
public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);
    int N = scanner.nextInt(); // 分子
    int D = scanner.nextInt(); // 分母

    int result = N / D;
    N = N % D;
    // 余数
    if (N == 0) {
        System.out.println(result + ".0");
    } else {
        // r是每次除之后的整数部分，len是循环节长度
        int r, len = 0;
        // i是结果的长度
        int i = 0;
        // 余数是否出现
        int[] remain = new int[100];
        // 余数出现次数
        int[] time = new int[100];
        Arrays.fill(remain, -1);
        Arrays.fill(time, 0);
        // 整个余数部分，包含两次循环节
        StringBuilder number = new StringBuilder();
        // 循环节第一次出现置1，第二次出现置2，第三次就遍历后续部分，确定循环节长度
        while (N != 0 && i < 1000) {
            N = N * 10;
            r = N / D;
            N = N % D;
            // 第一次出现
            if (remain[N] == r) {
                // 第二次出现 
                if (time[N] != 2)
                    time[N]++;
                // 第三次出现
                else {
                    for (int j = 0; j < D; j++) {
                        if (remain[j] != -1 && time[j] > 1)
                            len++;
                    }
                    break;
                }
            } else {
                remain[N] = r;
                time[N] = 1;
            }
            number.append((char) (r + '0'));
            i++;
        }
        String resultStr;
        if (N != 0 && len > 0) {
            // 截取，包含两个循环节
            resultStr = result + "." + number.substring(0, i - len * 2) + "(" + number.substring(i - len) +  ")";
            System.out.println(resultStr);
            return;
        }
        resultStr = result + "." + number.toString();
        System.out.println(resultStr);
    }
```

## 小于n最大数

```java
/*
        数字从左往右分析。
        数组是递增有序的，从右往左分析，也就是先取最大的，再取次大的。
        目的：在数组中找到等于该位的元素或者小于该位元素的最大值
        如果数组中当前元素小于数字该位的值，就取上该最大元素，后面就不用分析了，全部填充该最大元素
        如果数组中当前元素等于数字该位的值，就继续分析数字的下一位
        如果数组中最小的元素都大于数字该位的值，就看一下当前分析的数字位数是第几位。如果是第一位，则继续从第二位开始；如果不是第一位，就退回一步
        o(m*n)  m是递归调用深度，最深是str长度，n是函数内部循环次数
        o(m)    递归深度
*/
static String str = "21121";
static int[] arr = {2, 4, 9};
static boolean dfs(int index, boolean flag, int sum){
    // 已经找到答案，返回
    if (index == str.length()){
        System.out.println(sum);
        return true;
    }
    if (flag){
        // 前一位小于当前位
        // 后面全填充最大的
        return dfs(index + 1,true,sum * 10 + arr[arr.length - 1]);
    } else {
        // 拿到当前字符
        int tmp = str.charAt(index) - '0';
        // 从右向左遍历数组
        for (int i = arr.length - 1; i >= 0; i--){
            // 如果相同，判断下一位
            if (arr[i] == tmp){
                if (dfs(index + 1,false,sum * 10 + arr[i])){
                    return true;
                }
            } else if (arr[i] < tmp) {
                // 如果找到比str当前数字小的数，就填充该数，后面都填充最大数，将flag设置true
                if (dfs(index + 1,true,sum * 10 + arr[i])){
                    return true;
                }
            }
        }
    }
    // 数组中最小的元素都大于数字该位的值
    if (index != 0) {
        return false;
    } else {
        // index=0，说明数组最小值比第1位大，舍弃第1位，后面全填最大值
        return dfs(index + 1,true, sum);
    }
}
```

# oppo

笔试

## 二进制翻转

小0有一个长度为 n的数组a,他现在想要选择其中一个数字进行 进制翻转"操作， 他想知道有多少种可能的选择方式，使得操作后的数组总和比不操作更大。

二进制翻转: 指将x的二进制翻转，翻转后去除前导0。

(例如: 12 = (1100)2，f(12)= (0011)2=3. )

输出为合法的方案数

``` java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        long[] a = new long[n];
        
        for (int i = 0; i < n; i++) {
            a[i] = scanner.nextLong();
        }
        
        int count = 0;
        
        for (int i = 0; i < n; i++) {
            long original = a[i];
            // 反转之后的值
            long reversed = reverseBits(original);
            
            // 比较
            if (reversed > original) {
                count++;
            }
        }
        
        System.out.println(count);
    }
    
    // 计算翻转之后的值
    private static long reverseBits(long x) {
        long result = 0;
        while (x > 0) {
            // result先左移1位，再获取x最后1位，设置到result最低位
            result = result << 1 | (x & 1);
            // xw
            x >>= 1;
        }
        return result;
    }
}
```

​	
